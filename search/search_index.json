{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"installation/","text":"Installation Overview Backrefs is a wrapper around Python's built-in Re and the 3 rd party Regex library. Backrefs adds various additional back references (and a couple other features) that are known to some regular expression engines, but not to Python's Re and/or Regex. The supported references actually vary depending on the regular expression engine being used as the engine may already have support for some, or things that prevent implementation of a feature. Backrefs comes in two flavors: bre (a Re wrapper) and bregex (a Regex wrapper). Installation There are a couple of recommended ways to install Backrefs. Install with pip: $ pip install backrefs Install with optional requirement regex : $ pip install backrefs [ extras ] Install locally from source via: $ python setup.py build $ python setup.py install If developing Backrefs, you can install via: $ pip install --editable . This method will allow you to instantly see your changes without reinstalling which is great for developing.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#overview","text":"Backrefs is a wrapper around Python's built-in Re and the 3 rd party Regex library. Backrefs adds various additional back references (and a couple other features) that are known to some regular expression engines, but not to Python's Re and/or Regex. The supported references actually vary depending on the regular expression engine being used as the engine may already have support for some, or things that prevent implementation of a feature. Backrefs comes in two flavors: bre (a Re wrapper) and bregex (a Regex wrapper).","title":"Overview"},{"location":"installation/#installation_1","text":"There are a couple of recommended ways to install Backrefs. Install with pip: $ pip install backrefs Install with optional requirement regex : $ pip install backrefs [ extras ] Install locally from source via: $ python setup.py build $ python setup.py install If developing Backrefs, you can install via: $ pip install --editable . This method will allow you to instantly see your changes without reinstalling which is great for developing.","title":"Installation"},{"location":"refs/","text":"Supported References Search Back References Re and Regex out of the box have very different feature sets. Backrefs tailors the supported features for each regular expression engine. For instance, Regex already supports Unicode properties, so Backrefs does not attempt to provide such support. Re LOCALE and Character Properties Backrefs does not consider LOCALE when inserting POSIX or Unicode properties. When forced int ASCII mode, either by the ASCII (or LOCALE ) flag or when operating on a byte string, Unicode properties are restricted to the ASCII range. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\p{UnicodeProperty} Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\pX Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\pL would be equivalent to \\p{L} or \\p{Letter} . \\P{UnicodeProperty} Inverse Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\PX Inverse Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\PL would be equivalent to \\P{L} or \\P{Letter} . [[:alnum:]] Though not really a back reference, support for POSIX style character classes is available. See POSIX Style Properties for more info. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. \\m Start word boundary. Translates to \\b(?=\\w) . \\M End word boundary. Translates to \\b(?<=\\w) . \\h Horizontal whitespace. Equivalent to using [[:blank:]] or [\\t\\p{Zs}] . \\R Generic line breaks. This will use the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85\\u2028\\u2029]) which is roughly equivalent the to atomic group form that other engines use: (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) . When applied to byte strings, the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85]) will be used. \\X Grapheme clusters. This will use the pattern (?:\\PM\\pM*(?!\\pM)) which is roughly equivalent to the atomic group form that other engines have used in the past: (?>\\PM\\pM*) . This does not implement full, proper grapheme clusters like the 3 rd party Regex module does as this would require changes to the Re core engine. Regex Note Regex already natively supports \\p{...} , \\P{...} , \\pX , \\PX , \\N{...} , \\X , \\h , \\m , and \\M so Backrefs does not attempt to add this to search patterns. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\R Generic line breaks. When searching a Unicode string, this will use the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) , and when applied to byte strings, the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85]) will be used. Replace Back References The replace back references below apply to both Re and Regex and are essentially non-specific to the regular expression engine being used. Casing is applied to both the literal text and the replacement groups within the replace template. In most cases you'd only need to wrap the groups, but it may be useful to apply casing to the literal portions if you are dynamically assembling replacement patterns. LOCALE and Casing LOCALE is not considered when applying character casing. Unicode casing is applied in Unicode strings and ASCII casing is applied to byte strings. Back References Description \\c Uppercase the next character. \\l Lowercase the next character. \\C...\\E Apply uppercase to all characters until either the end of the string, the end marker \\E is found, or another \\C or \\L is encountered. \\L...\\E Apply lowercase to all characters until either the end of the string, the end marker \\E is found, or another \\L or \\C is encountered. \\U Wide Unicode character \\U00000057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\u Narrow Unicode character \\u0057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\x Byte character \\x57 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. Tip Complex configurations of casing should work fine. \\L\\cTEST\\E \u2192 Test \\c\\LTEST\\E \u2192 test \\L\\cTEST \\cTEST\\E \u2192 Test Test Unicode Properties New in 5.0 5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the ASCII flag along with more extensive testing and bug fixes. A number of various Unicode properties are supported in Backrefs, but only for Re as Regex already has its own implementation of Unicode properties. Some properties may not be available on certain Python versions due to the included Unicode build. It is important to note that Backrefs handles Unicode properties by transforming them to character classes with all the associated characters: \\p{Cs} \u2192 [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff] . Because of this, Backrefs can create really large regular expressions that the underlying engine must walk through. In short, Re with Backrefs will never be as efficient or fast as using Regex's Unicode properties, but it is very useful when you need or want to use Re. Also, keep in mind that there are most likely some differences between Regex's Unicode Properties and Backrefs' Unicode properties. One notable difference is Regex does not currently implement script_extensions while Backrefs' does and uses them as the default when specifying them in the form \\p{IsScriptValue} or \\p{ScriptValue} just like Perl does. See Property Short Names for more info. Supported Properties Aliases Age Bidi_Class bc Bidi_Paired_Bracket_Type bpt Binary Block blk Canonical_Combining_Class ccc Decomposition_Type dt East_Asian_Width ea General_Category gc Grapheme_Cluster_Break gcb Hangul_Syllable_Type hst Indic_Positional_Category inpc Indic_Syllabic_Category insc Joining_Group jg Joining_Type jt Line_Break lb NFC_Quick_Check nfcqc NFD_Quick_Check nfdqc NFKC_Quick_Check nfkcqc NFKD_Quick_Check nfkdqc Numeric_Type nt Numeric_Value nv Script sc Script_Extensions scx Sentence_Break sb Vertical_Orientation (Python 3.7+) vt Word_Break wb Note The Binary property is not actually a property, but more a type of Unicode property. The available binary properties may differ from Unicode version to Unicode version. New 4.4.0 Python 3.9 now uses Unicode 13, and with that comes various new binary properties: emoji , emojicomponent , emojimodifier , emojimodifierbase , and emojipresentation . Associated aliases are also included: ecomp , emod , ebase , and epres . Exhaustive documentation on all these properties and their values is not currently provided. In general, we'll cover the syntax rules, and special short name handling to those rules for specific properties. Though we will outline all the values for General Category, we will not outline all of the valid values for the other properties. You can look at Perl's Unicode property documentation to get an idea of what values are appropriate for a given property, but keep in mind, syntax may vary from Perl's syntax. Unicode properties are specific to search patterns and can be used to specify a request to match all the characters in a specific Unicode property. Unicode properties can be used in byte strings, but the patterns will be restricted to the ASCII range. Additionally, Unicode properties are sensitive to the ASCII flag and will have their range limited to ASCII if used. The LOCALE flag is treated as ASCII in relation to Unicode properties. Syntax Unicode properties can be specified with the format: \\p{property=value} , \\p{property:value} . You can also do inverse properties by using the ^ character ( \\p{^property=value} ) or by using a capital P ( \\P{property=value} or \\P{property:value} ). Unicode properties may only have one property specified between the curly braces. If you want to use multiple properties to capture a singe character, create a character class: [\\p{UnicodeProperty}\\p{OtherUnicodeProperty}] . When specifying a property, the property and value matching is case insensitive and characters like [ -_] will be stripped out. So the following are all equivalent: \\p{Uppercase_Letter} , \\p{Uppercase-letter} , \\p{UPPERCASELETTER} , \\p{upper case letter} . There are a number of binary properties. In general, binary properties are specified by stating the binary property and a boolean value. True values can be Yes , Y , True , or T . False values can be No , N , False , or F . For example, to specify characters that are \"alphabetic\", we can use \\p{Alphabetic: Y} . To specify characters that are not \"alphabetic\": \\p{Alphabetic: N} . Property Short Names General Category, Script Extensions, Blocks, and Binary all can be specified in a short form using just their name or alias: \\p{value} , but they will be evaluated in the following order to resolve name conflicts as some the same value that is used in Script may be used in Blocks etc. General Category Script Extensions Binary Blocks Script Extensions and Binary properties can also be defined in the format IsValue . For instance, if we wanted to match characters in the Latin script, we could use the syntax \\p{IsLatin} , which would be the same as \\p{Latin} or \\p{scx: Latin} . For Binary properties, \\p{IsAlphabetic} is the same as \\p{Alphabetic: Y} or \\p{Alphabetic} . Block properties have a similar short form as Script and Binary properties. For Blocks you can use InValue to specify a block. If we wanted to match characters in the Basic_Latin block, we could use the syntax \\p{InBasic_Latin} . This would be the same as \\p{Block: Basic_Latin} or \\p{Basic_Latin} . Short Name Conflicts When it comes to short names, each new Unicode version, there is a risk that new properties could cause conflicts with existing names and/or aliases. Currently, most of the conflicts involve the Block properties. To reduce friction, they are evaluated last. Generally, it is discouraged to use short names for Block properties. But the option is still supported, but Block properties will be evaluated last. There are currently no known conflicts with In* properties, but in future Unicode versions there could. As for short names for scripts, Binary, or General Categories, there is always the possibility that these could break in the future as well. Generally, more explicit is better and probably safer. Lastly, you can specify general category properties in the form \\pX where X is the single letter terse property form. In this form, you can only use the single character values. So you could specify Letter , whose terse form is L with \\pL , but cannot specify Cased_Letter which has a terse form of Lc . See the table below to see all the Unicode General Category values and their terse forms. Verbose Property Form Terse Property Form Other C Control Cc Format Cf Surrogate Cs Private_Use Co Unassigned Cn Letter L Cased_Letter L& or Lc Uppercase_Letter Lu Lowercase_Letter Ll Titlecase_Letter Lt Modifier_Letter Lm Other_Letter Lo Mark M Nonspacing_Mark Mc Spacing_Mark Me Enclosing_Mark Md Number N Decimal_Number Nd Letter_Number Nl Other_Number No Punctuation P Connector_Punctuation Pc Dash_Punctuation Pd Open_Punctuation Ps Close_Punctuation Pe Initial_Punctuation Pi Final_Punctuation Pf Other_Punctuation Po Symbol S Math_Symbol Sm Currency_Symbol Sc Modifier_Symbol Sk Other_Symbol So Separator Z Space_Separator Zs Line_Separator Zl Paragraph_Separator Z POSIX Style Properties New in 5.0 5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the ASCII flag along with more extensive testing and bug fixes. Additionally, POSIX style properties are now just an extension of normal Unicode properties. All the POSIX names are available and now conform to the Unicode specification for POSIX compatibility . Read on to learn more. Backrefs allows for POSIX style properties in the form [:name:] . These properties can only be used inside character classes and are another form for expressing Unicode properties. Any Unicode property that can be expressed via the \\p{name} form can also be expressed in the [:name:] form. To illustrate, the following are all the same: [[:upper:]] == [\\p{upper}] [[:^upper:]] == [\\p{^upper}] [[:alpha=yes:]] == [\\p{alpha=yes}] A number of POSIX property names are available via compatibility properties as outlined in the Unicode specification for POSIX compatibility . These properties will operate in the Unicode range and the ASCII range depending on the regular expression mode. These patterns, like all Unicode properties, are sensitive to the ASCII flag (or LOCALE which will treat them as ASCII ). It is important to note that whether used in the form [[:name:]] or \\p{name} , each POSIX name is available both with and without the posix prefix, but it is recommended to use the posix prefix to get the POSIX definition of the pattern as number of patterns have both a POSIX and Unicode definition that differ. The Unicode specification for POSIX compatibility outlines all the POSIX compatible properties and the ones which have dual definitions: punct , alnum , digit , and xdigit all have a Unicode standard and a POSIX compatibility variant and must be accessed with the posix prefix to get the POSIX form. In the table below, patterns with -- mean [[in this] -- [but not this]] . [:posix:] \\p{Posix} ASCII Unicode alpha Alpha [a-zA-Z] \\p{Alphabetic} alnum PosixAlnum [[:alpha:][:digit:]] [[:alpha:][:digit:]] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] \\p{Cc} digit PosixDigit [0-9] [0-9] graph Graph [^ [:cntrl:]] [^[:space:][:cntrl:]\\p{Cn}\\p{Cs}] lower Lower [a-z] [\\p{Lowercase}] print Print [[:graph:] ] [[\\p{P}\\p{S}]--[\\p{alpha}]] punct PosixPunct [!\\\"\\#$%&'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~] [[[:graph:][:blank:]]--[[:cntrl:]]] space Space [ \\t\\r\\n\\v\\f] [\\p{Whitespace}] upper Upper [A-Z] [\\p{Uppercase}] xdigit PosixXDigit [A-Fa-f0-9] [A-Fa-f0-9] Compatibility Properties New in 5.0 While many of the properties were available before 5.0, word is newly available. And all the properties now conform to the Unicode specification for POSIX compatibility . Unicode specification for POSIX compatibility defines a number of properties, many of which double as Posix properties . These properties can be accessed via \\p{name} or [[:name:]] . In the table below, patterns with -- mean [[in this] -- [but not this]] . \\p{Posix} Unicode Alpha \\p{Alphabetic} Alnum [\\p{Alpha}\\p{Digit}] Blank [\\p{Zs}\\t] Cntrl \\p{Cc} Digit \\p{Nd} Graph [^\\p{Space}\\p{Cntrl}\\p{Cn}\\p{Cs}] Lower \\p{Lowercase} Print [[\\p{P}\\p{S}]--[\\p{Alpha}]] Punct \\p{P} Space \\p{Whitespace} Upper \\p{Uppercase} Word [\\p{Alnum}\\p{M}\\p{Pc}\\p{JoinControl}] XDigit [\\p{Nd}\\p{HexDigit}]","title":"Supported References"},{"location":"refs/#supported-references","text":"","title":"Supported References"},{"location":"refs/#search-back-references","text":"Re and Regex out of the box have very different feature sets. Backrefs tailors the supported features for each regular expression engine. For instance, Regex already supports Unicode properties, so Backrefs does not attempt to provide such support.","title":"Search Back References"},{"location":"refs/#re","text":"LOCALE and Character Properties Backrefs does not consider LOCALE when inserting POSIX or Unicode properties. When forced int ASCII mode, either by the ASCII (or LOCALE ) flag or when operating on a byte string, Unicode properties are restricted to the ASCII range. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\p{UnicodeProperty} Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\pX Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\pL would be equivalent to \\p{L} or \\p{Letter} . \\P{UnicodeProperty} Inverse Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\PX Inverse Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\PL would be equivalent to \\P{L} or \\P{Letter} . [[:alnum:]] Though not really a back reference, support for POSIX style character classes is available. See POSIX Style Properties for more info. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. \\m Start word boundary. Translates to \\b(?=\\w) . \\M End word boundary. Translates to \\b(?<=\\w) . \\h Horizontal whitespace. Equivalent to using [[:blank:]] or [\\t\\p{Zs}] . \\R Generic line breaks. This will use the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85\\u2028\\u2029]) which is roughly equivalent the to atomic group form that other engines use: (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) . When applied to byte strings, the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85]) will be used. \\X Grapheme clusters. This will use the pattern (?:\\PM\\pM*(?!\\pM)) which is roughly equivalent to the atomic group form that other engines have used in the past: (?>\\PM\\pM*) . This does not implement full, proper grapheme clusters like the 3 rd party Regex module does as this would require changes to the Re core engine.","title":"Re"},{"location":"refs/#regex","text":"Note Regex already natively supports \\p{...} , \\P{...} , \\pX , \\PX , \\N{...} , \\X , \\h , \\m , and \\M so Backrefs does not attempt to add this to search patterns. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\R Generic line breaks. When searching a Unicode string, this will use the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) , and when applied to byte strings, the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85]) will be used.","title":"Regex"},{"location":"refs/#replace-back-references","text":"The replace back references below apply to both Re and Regex and are essentially non-specific to the regular expression engine being used. Casing is applied to both the literal text and the replacement groups within the replace template. In most cases you'd only need to wrap the groups, but it may be useful to apply casing to the literal portions if you are dynamically assembling replacement patterns. LOCALE and Casing LOCALE is not considered when applying character casing. Unicode casing is applied in Unicode strings and ASCII casing is applied to byte strings. Back References Description \\c Uppercase the next character. \\l Lowercase the next character. \\C...\\E Apply uppercase to all characters until either the end of the string, the end marker \\E is found, or another \\C or \\L is encountered. \\L...\\E Apply lowercase to all characters until either the end of the string, the end marker \\E is found, or another \\L or \\C is encountered. \\U Wide Unicode character \\U00000057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\u Narrow Unicode character \\u0057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\x Byte character \\x57 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. Tip Complex configurations of casing should work fine. \\L\\cTEST\\E \u2192 Test \\c\\LTEST\\E \u2192 test \\L\\cTEST \\cTEST\\E \u2192 Test Test","title":"Replace Back References"},{"location":"refs/#unicode-properties","text":"New in 5.0 5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the ASCII flag along with more extensive testing and bug fixes. A number of various Unicode properties are supported in Backrefs, but only for Re as Regex already has its own implementation of Unicode properties. Some properties may not be available on certain Python versions due to the included Unicode build. It is important to note that Backrefs handles Unicode properties by transforming them to character classes with all the associated characters: \\p{Cs} \u2192 [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff] . Because of this, Backrefs can create really large regular expressions that the underlying engine must walk through. In short, Re with Backrefs will never be as efficient or fast as using Regex's Unicode properties, but it is very useful when you need or want to use Re. Also, keep in mind that there are most likely some differences between Regex's Unicode Properties and Backrefs' Unicode properties. One notable difference is Regex does not currently implement script_extensions while Backrefs' does and uses them as the default when specifying them in the form \\p{IsScriptValue} or \\p{ScriptValue} just like Perl does. See Property Short Names for more info. Supported Properties Aliases Age Bidi_Class bc Bidi_Paired_Bracket_Type bpt Binary Block blk Canonical_Combining_Class ccc Decomposition_Type dt East_Asian_Width ea General_Category gc Grapheme_Cluster_Break gcb Hangul_Syllable_Type hst Indic_Positional_Category inpc Indic_Syllabic_Category insc Joining_Group jg Joining_Type jt Line_Break lb NFC_Quick_Check nfcqc NFD_Quick_Check nfdqc NFKC_Quick_Check nfkcqc NFKD_Quick_Check nfkdqc Numeric_Type nt Numeric_Value nv Script sc Script_Extensions scx Sentence_Break sb Vertical_Orientation (Python 3.7+) vt Word_Break wb Note The Binary property is not actually a property, but more a type of Unicode property. The available binary properties may differ from Unicode version to Unicode version. New 4.4.0 Python 3.9 now uses Unicode 13, and with that comes various new binary properties: emoji , emojicomponent , emojimodifier , emojimodifierbase , and emojipresentation . Associated aliases are also included: ecomp , emod , ebase , and epres . Exhaustive documentation on all these properties and their values is not currently provided. In general, we'll cover the syntax rules, and special short name handling to those rules for specific properties. Though we will outline all the values for General Category, we will not outline all of the valid values for the other properties. You can look at Perl's Unicode property documentation to get an idea of what values are appropriate for a given property, but keep in mind, syntax may vary from Perl's syntax. Unicode properties are specific to search patterns and can be used to specify a request to match all the characters in a specific Unicode property. Unicode properties can be used in byte strings, but the patterns will be restricted to the ASCII range. Additionally, Unicode properties are sensitive to the ASCII flag and will have their range limited to ASCII if used. The LOCALE flag is treated as ASCII in relation to Unicode properties.","title":"Unicode Properties"},{"location":"refs/#syntax","text":"Unicode properties can be specified with the format: \\p{property=value} , \\p{property:value} . You can also do inverse properties by using the ^ character ( \\p{^property=value} ) or by using a capital P ( \\P{property=value} or \\P{property:value} ). Unicode properties may only have one property specified between the curly braces. If you want to use multiple properties to capture a singe character, create a character class: [\\p{UnicodeProperty}\\p{OtherUnicodeProperty}] . When specifying a property, the property and value matching is case insensitive and characters like [ -_] will be stripped out. So the following are all equivalent: \\p{Uppercase_Letter} , \\p{Uppercase-letter} , \\p{UPPERCASELETTER} , \\p{upper case letter} . There are a number of binary properties. In general, binary properties are specified by stating the binary property and a boolean value. True values can be Yes , Y , True , or T . False values can be No , N , False , or F . For example, to specify characters that are \"alphabetic\", we can use \\p{Alphabetic: Y} . To specify characters that are not \"alphabetic\": \\p{Alphabetic: N} .","title":"Syntax"},{"location":"refs/#property-short-names","text":"General Category, Script Extensions, Blocks, and Binary all can be specified in a short form using just their name or alias: \\p{value} , but they will be evaluated in the following order to resolve name conflicts as some the same value that is used in Script may be used in Blocks etc. General Category Script Extensions Binary Blocks Script Extensions and Binary properties can also be defined in the format IsValue . For instance, if we wanted to match characters in the Latin script, we could use the syntax \\p{IsLatin} , which would be the same as \\p{Latin} or \\p{scx: Latin} . For Binary properties, \\p{IsAlphabetic} is the same as \\p{Alphabetic: Y} or \\p{Alphabetic} . Block properties have a similar short form as Script and Binary properties. For Blocks you can use InValue to specify a block. If we wanted to match characters in the Basic_Latin block, we could use the syntax \\p{InBasic_Latin} . This would be the same as \\p{Block: Basic_Latin} or \\p{Basic_Latin} . Short Name Conflicts When it comes to short names, each new Unicode version, there is a risk that new properties could cause conflicts with existing names and/or aliases. Currently, most of the conflicts involve the Block properties. To reduce friction, they are evaluated last. Generally, it is discouraged to use short names for Block properties. But the option is still supported, but Block properties will be evaluated last. There are currently no known conflicts with In* properties, but in future Unicode versions there could. As for short names for scripts, Binary, or General Categories, there is always the possibility that these could break in the future as well. Generally, more explicit is better and probably safer. Lastly, you can specify general category properties in the form \\pX where X is the single letter terse property form. In this form, you can only use the single character values. So you could specify Letter , whose terse form is L with \\pL , but cannot specify Cased_Letter which has a terse form of Lc . See the table below to see all the Unicode General Category values and their terse forms. Verbose Property Form Terse Property Form Other C Control Cc Format Cf Surrogate Cs Private_Use Co Unassigned Cn Letter L Cased_Letter L& or Lc Uppercase_Letter Lu Lowercase_Letter Ll Titlecase_Letter Lt Modifier_Letter Lm Other_Letter Lo Mark M Nonspacing_Mark Mc Spacing_Mark Me Enclosing_Mark Md Number N Decimal_Number Nd Letter_Number Nl Other_Number No Punctuation P Connector_Punctuation Pc Dash_Punctuation Pd Open_Punctuation Ps Close_Punctuation Pe Initial_Punctuation Pi Final_Punctuation Pf Other_Punctuation Po Symbol S Math_Symbol Sm Currency_Symbol Sc Modifier_Symbol Sk Other_Symbol So Separator Z Space_Separator Zs Line_Separator Zl Paragraph_Separator Z","title":"Property Short Names"},{"location":"refs/#posix-style-properties","text":"New in 5.0 5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the ASCII flag along with more extensive testing and bug fixes. Additionally, POSIX style properties are now just an extension of normal Unicode properties. All the POSIX names are available and now conform to the Unicode specification for POSIX compatibility . Read on to learn more. Backrefs allows for POSIX style properties in the form [:name:] . These properties can only be used inside character classes and are another form for expressing Unicode properties. Any Unicode property that can be expressed via the \\p{name} form can also be expressed in the [:name:] form. To illustrate, the following are all the same: [[:upper:]] == [\\p{upper}] [[:^upper:]] == [\\p{^upper}] [[:alpha=yes:]] == [\\p{alpha=yes}] A number of POSIX property names are available via compatibility properties as outlined in the Unicode specification for POSIX compatibility . These properties will operate in the Unicode range and the ASCII range depending on the regular expression mode. These patterns, like all Unicode properties, are sensitive to the ASCII flag (or LOCALE which will treat them as ASCII ). It is important to note that whether used in the form [[:name:]] or \\p{name} , each POSIX name is available both with and without the posix prefix, but it is recommended to use the posix prefix to get the POSIX definition of the pattern as number of patterns have both a POSIX and Unicode definition that differ. The Unicode specification for POSIX compatibility outlines all the POSIX compatible properties and the ones which have dual definitions: punct , alnum , digit , and xdigit all have a Unicode standard and a POSIX compatibility variant and must be accessed with the posix prefix to get the POSIX form. In the table below, patterns with -- mean [[in this] -- [but not this]] . [:posix:] \\p{Posix} ASCII Unicode alpha Alpha [a-zA-Z] \\p{Alphabetic} alnum PosixAlnum [[:alpha:][:digit:]] [[:alpha:][:digit:]] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] \\p{Cc} digit PosixDigit [0-9] [0-9] graph Graph [^ [:cntrl:]] [^[:space:][:cntrl:]\\p{Cn}\\p{Cs}] lower Lower [a-z] [\\p{Lowercase}] print Print [[:graph:] ] [[\\p{P}\\p{S}]--[\\p{alpha}]] punct PosixPunct [!\\\"\\#$%&'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~] [[[:graph:][:blank:]]--[[:cntrl:]]] space Space [ \\t\\r\\n\\v\\f] [\\p{Whitespace}] upper Upper [A-Z] [\\p{Uppercase}] xdigit PosixXDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Style Properties"},{"location":"refs/#compatibility-properties","text":"New in 5.0 While many of the properties were available before 5.0, word is newly available. And all the properties now conform to the Unicode specification for POSIX compatibility . Unicode specification for POSIX compatibility defines a number of properties, many of which double as Posix properties . These properties can be accessed via \\p{name} or [[:name:]] . In the table below, patterns with -- mean [[in this] -- [but not this]] . \\p{Posix} Unicode Alpha \\p{Alphabetic} Alnum [\\p{Alpha}\\p{Digit}] Blank [\\p{Zs}\\t] Cntrl \\p{Cc} Digit \\p{Nd} Graph [^\\p{Space}\\p{Cntrl}\\p{Cn}\\p{Cs}] Lower \\p{Lowercase} Print [[\\p{P}\\p{S}]--[\\p{Alpha}]] Punct \\p{P} Space \\p{Whitespace} Upper \\p{Uppercase} Word [\\p{Alnum}\\p{M}\\p{Pc}\\p{JoinControl}] XDigit [\\p{Nd}\\p{HexDigit}]","title":"Compatibility Properties"},{"location":"usage/","text":"Introduction Importing Backrefs comes in two flavors: bre (a Re wrapper) and bregex (a Regex wrapper). You can import either one simply by importing it from the backrefs library. Regex must be installed if using bregex . from backrefs import bre from backrefs import bregex Searches Backrefs preprocesses search patterns looking for new syntax that it replaces with compatible regular expressions for the given regular expression engine. For instance, Backrefs implements the \\h reference in Re, and when compiled, we get an Re object with a regular expression pattern that captures horizontal whitespace characters: >>> bre . compile ( '\\h' ) backrefs.bre.Bre(re.compile('[\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000]'), auto_compile=True) It can be seen that the Backrefs object is simply wrapped around an Re compiled pattern, and we see that \\h was replaced with [\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000] . This basic approach is used to implement all sorts of references from Unicode properties: >>> bre . compile ( r 'test \\p {Cs} ' ) backrefs.bre.Bre(re.compile('test [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]'), auto_compile=True) To start and end word boundaries: >>> bre . compile ( r '\\mtest\\M' ) backrefs.bre.Bre(re.compile('\\\\b(?=\\\\w)test\\\\b(?<=\\\\w)'), auto_compile=True) A compiled Backrefs object has all the same functions as the regular expression's object, so you can use it in the same way to perform splits, matches, substitutions, and anything else. Replacements Replace templates are a little different than search patterns and require a bit more control to accomplish some of the replace features which is why a Backrefs object is wrapped around the returned Re object. The wrapper mirrors the regular expression object's shadows so that it can intercept the calls to sub , subn , etc. to process replacements before passing them to the regular expression engine. Like with searches, Backrefs preprocesses the replace string before passing it to the regular expression engine. Once Backrefs has parsed and altered the string as needed, it is then passed to the regular expression engine with the compiled search pattern to extract string literals and the group mapping. With this, Backrefs can assemble the replacement and inject new functionality on substitution. For instance, here we use the start and end markers of \\C and \\E to specify that the content in between should be capitalized. Traditionally, \\U and \\E is used, but since \\U is a Unicode escape in Python, we chose to use \\C . >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) 'SOMETEXT' Format Replacements The Regex library has a feature where you can use format strings to implement replacements. This is useful for Regex as it provides a way to access different captures when multiple are captured by a single group. Most likely it was born from the need to provide an easy way to access multiple captures as Regex stores all captures while Re stores only the last. >>> regex . subf ( r \"(\\w+) (\\w+)\" , \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> regex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' >>> regex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Backrefs implements format string replacements in a way that is similar to Regex's so that format replacements can be done in Re just like it can with Regex and provide additional features to both Re and Regex. While it is similar to Regex's implementation, there are some differences. >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' >>> bre . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \"\\c {word2} \\c {word1} \" , \"foo bar\" ) 'Bar Foo' Though you can use normal strings with Backrefs' format templates, it is recommended to use raw strings for format replacements as back slashes are handled special to implement lower casing and upper casing via the replace back references. In Backrefs, a template would look like r '\\L {1}{2} \\E' , and if you used a normal string it would look like ' \\\\ L {1}{2} \\\\ E' . Backrefs also uses escapes in this manner to allow Unicode references in raw string format templates as well. Here we center the replacement, padding it out to 8 characters, using | (Unicode \\u007c ) for the padding. We also use casing references ( \\C...\\E ) to capitalize the replacement group. >>> bregex . subf ( r '(test)' , r '\\C{0:\\u007c^8}\\E' , 'test' ) '||TEST||' Backrefs implements a subset of the Format Specification Mini-Language ( format_spec ) that allows for a few more additional features that Regex doesn't. As regular expression replacements are only working with string replacements (or byte strings), only string features are available with the format_spec . replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= <described in the next section> format_spec ::= [[fill]align][0][width][type] fill ::= <any character> align ::= \"<\" | \">\" | \"^\" width ::= integer type ::= \"s\" Note that in situations such as {:030} , where a width has a leading zero and no alignment specified, this would normally trigger the integer alignment = , but since integer features are not implemented, this would fail. Backrefs allows format strings to work for byte strings as well. In almost all instances, using conversion types won't make sense in a regular expression replace as the objects will already be strings in the needed format, but if you were to use a conversion, ASCII would be assumed, and the object or Unicode string would be encoded with backslashreplace . When using Backrefs' format replace, it should feel similar to Regex's format replace, except you will use raw strings: >>> bregex . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> bregex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' If using bregex , you can even index into groups that have multiple captures. >>> bregex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' You can also use {} {} which is the same as {0} {1} . >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {} => \\C {} {} \\E\" , \"foo bar\" ) 'foo bar => FOO BAR' Backrefs also provides an expand variant for format templates called expandf . >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> m = pattern . match ( 'foo bar' ) >>> bre . expandf ( m , r \" {0} => {2} {1} \" ) 'foo bar => bar foo' Advanced Usage As noted, Backrefs wraps the regular expression object on compile with its own object. This is so it can provide the replace features seamlessly without the user having to do anything extra. But if you only wanted the search features, the compile_search method can be used to compile the pattern and directly return the regular expression object with no wrapper: >>> bre . compile_search ( r '(\\p {ascii} +)' ) re.compile('([\\x00-\\x7f]+)') Conversely, we could only use the replace features by compiling the pattern normally and giving it to the Backrefs API to create a replace object: >>> pattern = re . compile ( r '(\\w+)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'text' ) 'TEXT' You can also compile a replacement object directly from a backrefs object: >>> pattern = bre . compile ( r '(\\w+)' ) >>> replace = pattern . compile ( r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'text' ) 'TEXT' To pre-compile a format replace template, you can use the Backrefs' compile_replace method with the FORMAT flag. >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> replace = bre . compile_replace ( pattern , r \" {0} => {2} {1} \" , bre . FORMAT ) >>> m = pattern . match ( \"foo bar\" ) >>> replace ( m ) 'foo bar => bar foo' Pre-compiled pattern objects can also create a compiled format replace object using the FORMAT flag. >>> pattern = bre . compile ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" ) >>> replace = pattern . compile ( r \"\\c {word2} \\c {word1} \" , bre . FORMAT ) >>> pattern . subf ( replace , \"foo bar\" ) 'Bar Foo'","title":"Usage"},{"location":"usage/#introduction","text":"","title":"Introduction"},{"location":"usage/#importing","text":"Backrefs comes in two flavors: bre (a Re wrapper) and bregex (a Regex wrapper). You can import either one simply by importing it from the backrefs library. Regex must be installed if using bregex . from backrefs import bre from backrefs import bregex","title":"Importing"},{"location":"usage/#searches","text":"Backrefs preprocesses search patterns looking for new syntax that it replaces with compatible regular expressions for the given regular expression engine. For instance, Backrefs implements the \\h reference in Re, and when compiled, we get an Re object with a regular expression pattern that captures horizontal whitespace characters: >>> bre . compile ( '\\h' ) backrefs.bre.Bre(re.compile('[\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000]'), auto_compile=True) It can be seen that the Backrefs object is simply wrapped around an Re compiled pattern, and we see that \\h was replaced with [\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000] . This basic approach is used to implement all sorts of references from Unicode properties: >>> bre . compile ( r 'test \\p {Cs} ' ) backrefs.bre.Bre(re.compile('test [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]'), auto_compile=True) To start and end word boundaries: >>> bre . compile ( r '\\mtest\\M' ) backrefs.bre.Bre(re.compile('\\\\b(?=\\\\w)test\\\\b(?<=\\\\w)'), auto_compile=True) A compiled Backrefs object has all the same functions as the regular expression's object, so you can use it in the same way to perform splits, matches, substitutions, and anything else.","title":"Searches"},{"location":"usage/#replacements","text":"Replace templates are a little different than search patterns and require a bit more control to accomplish some of the replace features which is why a Backrefs object is wrapped around the returned Re object. The wrapper mirrors the regular expression object's shadows so that it can intercept the calls to sub , subn , etc. to process replacements before passing them to the regular expression engine. Like with searches, Backrefs preprocesses the replace string before passing it to the regular expression engine. Once Backrefs has parsed and altered the string as needed, it is then passed to the regular expression engine with the compiled search pattern to extract string literals and the group mapping. With this, Backrefs can assemble the replacement and inject new functionality on substitution. For instance, here we use the start and end markers of \\C and \\E to specify that the content in between should be capitalized. Traditionally, \\U and \\E is used, but since \\U is a Unicode escape in Python, we chose to use \\C . >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) 'SOMETEXT'","title":"Replacements"},{"location":"usage/#format-replacements","text":"The Regex library has a feature where you can use format strings to implement replacements. This is useful for Regex as it provides a way to access different captures when multiple are captured by a single group. Most likely it was born from the need to provide an easy way to access multiple captures as Regex stores all captures while Re stores only the last. >>> regex . subf ( r \"(\\w+) (\\w+)\" , \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> regex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' >>> regex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Backrefs implements format string replacements in a way that is similar to Regex's so that format replacements can be done in Re just like it can with Regex and provide additional features to both Re and Regex. While it is similar to Regex's implementation, there are some differences. >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' >>> bre . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \"\\c {word2} \\c {word1} \" , \"foo bar\" ) 'Bar Foo' Though you can use normal strings with Backrefs' format templates, it is recommended to use raw strings for format replacements as back slashes are handled special to implement lower casing and upper casing via the replace back references. In Backrefs, a template would look like r '\\L {1}{2} \\E' , and if you used a normal string it would look like ' \\\\ L {1}{2} \\\\ E' . Backrefs also uses escapes in this manner to allow Unicode references in raw string format templates as well. Here we center the replacement, padding it out to 8 characters, using | (Unicode \\u007c ) for the padding. We also use casing references ( \\C...\\E ) to capitalize the replacement group. >>> bregex . subf ( r '(test)' , r '\\C{0:\\u007c^8}\\E' , 'test' ) '||TEST||' Backrefs implements a subset of the Format Specification Mini-Language ( format_spec ) that allows for a few more additional features that Regex doesn't. As regular expression replacements are only working with string replacements (or byte strings), only string features are available with the format_spec . replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= <described in the next section> format_spec ::= [[fill]align][0][width][type] fill ::= <any character> align ::= \"<\" | \">\" | \"^\" width ::= integer type ::= \"s\" Note that in situations such as {:030} , where a width has a leading zero and no alignment specified, this would normally trigger the integer alignment = , but since integer features are not implemented, this would fail. Backrefs allows format strings to work for byte strings as well. In almost all instances, using conversion types won't make sense in a regular expression replace as the objects will already be strings in the needed format, but if you were to use a conversion, ASCII would be assumed, and the object or Unicode string would be encoded with backslashreplace . When using Backrefs' format replace, it should feel similar to Regex's format replace, except you will use raw strings: >>> bregex . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> bregex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' If using bregex , you can even index into groups that have multiple captures. >>> bregex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' You can also use {} {} which is the same as {0} {1} . >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {} => \\C {} {} \\E\" , \"foo bar\" ) 'foo bar => FOO BAR' Backrefs also provides an expand variant for format templates called expandf . >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> m = pattern . match ( 'foo bar' ) >>> bre . expandf ( m , r \" {0} => {2} {1} \" ) 'foo bar => bar foo'","title":"Format Replacements"},{"location":"usage/#advanced-usage","text":"As noted, Backrefs wraps the regular expression object on compile with its own object. This is so it can provide the replace features seamlessly without the user having to do anything extra. But if you only wanted the search features, the compile_search method can be used to compile the pattern and directly return the regular expression object with no wrapper: >>> bre . compile_search ( r '(\\p {ascii} +)' ) re.compile('([\\x00-\\x7f]+)') Conversely, we could only use the replace features by compiling the pattern normally and giving it to the Backrefs API to create a replace object: >>> pattern = re . compile ( r '(\\w+)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'text' ) 'TEXT' You can also compile a replacement object directly from a backrefs object: >>> pattern = bre . compile ( r '(\\w+)' ) >>> replace = pattern . compile ( r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'text' ) 'TEXT' To pre-compile a format replace template, you can use the Backrefs' compile_replace method with the FORMAT flag. >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> replace = bre . compile_replace ( pattern , r \" {0} => {2} {1} \" , bre . FORMAT ) >>> m = pattern . match ( \"foo bar\" ) >>> replace ( m ) 'foo bar => bar foo' Pre-compiled pattern objects can also create a compiled format replace object using the FORMAT flag. >>> pattern = bre . compile ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" ) >>> replace = pattern . compile ( r \"\\c {word2} \\c {word1} \" , bre . FORMAT ) >>> pattern . subf ( replace , \"foo bar\" ) 'Bar Foo'","title":"Advanced Usage"},{"location":"about/changelog/","text":"Changelog 5.0.0 NEW : Significant improvements to Unicode handling. A lot of testing was implemented to catch existing bugs and to improve result. NEW : POSIX style properties now handle all existing Unicode properties. NEW : POSIX properties now follow the Unicode specification for POSIX compatibility . Read the documentation to learn more. NEW : Unicode properties are now sensitive to the ASCII flag and will properly restrict the range of properties to the ASCII range even in Unicode strings. NEW : Removed the old deprecated search references: \\l , \\L , \\c , and \\C . These are available in various other forms: [[:lower:]] , \\p{lower} , etc. NEW : To reduce conflicts of naming, Binary properties are evaluated before Block properties when using short names. Block has conflicts with some other properties of various types, using short names for blocks is discouraged. FIX : Numerous fixes to existing Unicode properties: missing values, incorrect values, etc. 4.6 NEW : Provide wheels for all officially supported versions of Python. 4.5 NEW : Added new back reference \\h to Re. To get similar functionality with Regex, users must update to the latest Regex release. 4.4 NEW : Added the following binary properties for Unicode 13.0 support (Python 3.9): emoji , emojicomponent , emojimodifier , emojimodifierbase , and emojipresentation . Associated aliases are also included: ecomp , emod , ebase , and epres . 4.3 NEW : Install Regex library along Backrefs via pip install backrefs[extras] . NEW : Remove version and __version__ and remove associated deprecation code. 4.2.1 FIX : Fix Python 3.8 installation issue due to Unicode bundle having an incorrect encoding in some files. 4.2.0 NEW : Deprecate the search references \\l , \\L , \\c , and \\C . The POSIX alternatives (which these were shortcuts for) should be used instead: [[:lower:]] , [[:^lower:]] , [:upper:]] , and [[:^upper:]] respectively. NEW : Formally drop support for Python 3.4. 4.1.1 FIX : Later pre-release versions of Python 3.8 will support Unicode 12.1.0. 4.1 NEW : Add official support for Python 3.8. NEW : Vendor the Pep562 library instead of requiring as a dependency. NEW : Input parameters accept *args and **kwargs instead of specify every parameter in order to allow Backrefs to work even when the Re or Regex API changes. Change was made to support new Regex timeout parameter. 4.0.2 FIX : Fix compatibility issues with latest Regex versions. 4.0.1 FIX : Ensure that when generating the Unicode property tables, that the property files are read in with UTF-8 encoding. 4.0 NEW : Drop support for new features in Python 2. Python 2 support is limited to the 3.X.X series and will only receive bug fixes up to 2020. All new features moving forward will be on the 4.X.X series and will be for Python 3+ only. 3.6 NEW : Make version available via the new, and more standard, __version__ attribute and add the __version_info__ attribute as well. Deprecate the old version and version_info attribute for future removal. 3.5.2 FIX : Include zip for Unicode 11 (Python 3.7) to make installation more reliable. 3.5.1 FIX : POSIX character classes should not be part of a range. FIX : Replace string casing logic properly follows other implementations like Boost etc. \\L , \\C , and \\E should all terminate \\L , and \\C . \\l and \\c will be ignored if followed by \\C or \\L . 3.5 NEW : Use a more advanced format string implementation that implements all string features, included those found in format_spec . FIX : Relax validation so not to exclude valid named Unicode values. FIX : Caching issues where byte string patterns were confused with Unicode patterns. FIX : More protection against using conflicting string type combinations with search and replace. 3.4 NEW : Add support for generic line breaks ( \\R ) to Re. NEW : Add support for an overly simplified form of grapheme clusters ( \\X ) to Re. Roughly equivalent to (?>\\PM\\pM*) . NEW : Add support for Vertical_Orientation property for Unicode 10.0.0 on Python 3.7. 3.3 NEW : Add support for Indic_Positional_Category \\ Indic_Matra_Category and Indic_Syllabic_Category properties. 3.2.1 FIX : Bidi_Paired_Bracket_type property's None value should be equivalent to all characters that are not open or close characters. 3.2 NEW : Add support for Script_Extensions Unicode properties (Python 3 only as Python 2, Unicode 5.2.0 does not define these). Can be accessed via \\p{scripts_extensions: kana} or \\p{scx: kana} . NEW : When defining scripts with just their name \\p{Kana} , use Script_Extensions instead of Scripts . To get Scripts results, you must specify \\p{scripts: kana} or \\p{sc: scripts} . NEW : Add Bidi_Paired_Bracket_Type Unicode property (Python 3.4+ only). NEW : Add support for IsBinary for binary properties: \\p{IsAlphabetic} == \\p{Alphabetic: Y} . FIX : Tweaks/improvements to string iteration. 3.1.2 FIX : Properly escape any problematic characters in Unicode tables. 3.1.1 FIX : bregex.compile now supports additional keyword arguments for named lists like bregex.compile_search does. 3.1 NEW : Start and end word boundary back references are now specified with \\m and \\M like Regex does. \\< and \\> have been removed from Regex. FIX : Escaped \\< and \\> are no longer processed as Re is known to escape these in versions less than Python 3.7. 3.0.5 FIX : Process non raw string equivalent escaped Unicode on Python 2.7. FIX : Compiled objects should return the pattern string, not the pattern object via the property pattern . 3.0.4 FIX : Formally enable Python 3.7 support. FIX : Tweak to Unicode wide character handling. 3.0.3 FIX : Compiled search and replace objects should be hashable. FIX : Handle cases where a new compiled pattern object is passed back through compile functions. 3.0.2 FIX : Bregex purge was calling Re's purge instead of Regex's purge. 3.0.1 FIX : Do not accidentally \\. as a group in replace strings (don't use isdigit string method). FIX : Group names can start with _ in replace strings. FIX : Do not rely on Re for parsing string. FIX : Match behavior in \\g<group> parsing better. FIX : Raise some exceptions in a few places we weren't. 3.0 NEW : Added new compile function that returns a pattern object that feels like Re's and Regex's pattern object. NEW : Add some caching of search and replace patterns. NEW : Completely refactored algorithm for search and replace pattern augmentation. NEW : Add support for \\e for escape character \\x1b in both Re and Regex. NEW : Add support for \\R for generic newlines in the Regex module (Regex only). NEW : Support Unicode property form \\pP and \\PP . NEW : Add support for properly handling per group, scoped verbose flags in the preprocess step (Regex). NEW : Handle (?#comments) properly in the preprocess step. NEW : Add support for \\N in byte strings (characters out of range won't be included). NEW : Add support for \\p and \\P in byte strings (characters out of range won't be included). NEW : Add support for \\< and \\> word boundary escapes. FIX : Missing block properties on narrow systems when the property starts beyond the narrow limit. FIX : Fix issue where an invalid general category could sometimes pass and return no characters. FIX : Fix \\Q...\\E behavior so it is applied first as a separate step. No longer avoids \\Q...\\E in things like character groups or comments. FIX : Flag related parsing issues in Regex and Re Python 3.6+. 2.2 NEW : Proper support for \\N{Unicode Name} . FIX : Incomplete escapes will not be passed through, but will instead throw an error. For instance \\p should only be passed through if it is complete \\p{category} . Python 3.7 will error on this if we pass it through, and Python 3.6 will generate warnings. We should just consistently fail on it for all Python versions. 2.1 NEW : Handle Unicode and byte notation in Re replace templates. NEW : Rework algorithm to handle replace casing back references in Python 3.7 development builds in preparation for Python 3.7 release. NEW : Add support for case back references when using the Regex module's subf and subfn . NEW : Add new convenience method expandf to Regex that can take a format string and apply format style replaces. NEW : Add FORMAT flag to compile_replace to apply format style replaces when applicable. NEW : Add the same support that Regex has in relation to format style replacements to Re. NEW : Compiled replacements are now immutable. NEW : Various logic checking proper types and values. FIX : Fix octal/group logic in Regex and Re. FIX : Fix issue dealing with trailing backslashes in replace templates. 2.0 NEW : First attempt at bringing Python 3.7 support, fixing back reference logic, and adding new back reference. Released and then removed due to very poor behavior. 1.0.2 FIX : Issues related to downloading Unicode data and Unicode table generation. Include Unicode data in release. 1.0.1 FIX : Fixes for Python 3.6. 1.0 NEW : Initial release.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#500","text":"NEW : Significant improvements to Unicode handling. A lot of testing was implemented to catch existing bugs and to improve result. NEW : POSIX style properties now handle all existing Unicode properties. NEW : POSIX properties now follow the Unicode specification for POSIX compatibility . Read the documentation to learn more. NEW : Unicode properties are now sensitive to the ASCII flag and will properly restrict the range of properties to the ASCII range even in Unicode strings. NEW : Removed the old deprecated search references: \\l , \\L , \\c , and \\C . These are available in various other forms: [[:lower:]] , \\p{lower} , etc. NEW : To reduce conflicts of naming, Binary properties are evaluated before Block properties when using short names. Block has conflicts with some other properties of various types, using short names for blocks is discouraged. FIX : Numerous fixes to existing Unicode properties: missing values, incorrect values, etc.","title":"5.0.0"},{"location":"about/changelog/#46","text":"NEW : Provide wheels for all officially supported versions of Python.","title":"4.6"},{"location":"about/changelog/#45","text":"NEW : Added new back reference \\h to Re. To get similar functionality with Regex, users must update to the latest Regex release.","title":"4.5"},{"location":"about/changelog/#44","text":"NEW : Added the following binary properties for Unicode 13.0 support (Python 3.9): emoji , emojicomponent , emojimodifier , emojimodifierbase , and emojipresentation . Associated aliases are also included: ecomp , emod , ebase , and epres .","title":"4.4"},{"location":"about/changelog/#43","text":"NEW : Install Regex library along Backrefs via pip install backrefs[extras] . NEW : Remove version and __version__ and remove associated deprecation code.","title":"4.3"},{"location":"about/changelog/#421","text":"FIX : Fix Python 3.8 installation issue due to Unicode bundle having an incorrect encoding in some files.","title":"4.2.1"},{"location":"about/changelog/#420","text":"NEW : Deprecate the search references \\l , \\L , \\c , and \\C . The POSIX alternatives (which these were shortcuts for) should be used instead: [[:lower:]] , [[:^lower:]] , [:upper:]] , and [[:^upper:]] respectively. NEW : Formally drop support for Python 3.4.","title":"4.2.0"},{"location":"about/changelog/#411","text":"FIX : Later pre-release versions of Python 3.8 will support Unicode 12.1.0.","title":"4.1.1"},{"location":"about/changelog/#41","text":"NEW : Add official support for Python 3.8. NEW : Vendor the Pep562 library instead of requiring as a dependency. NEW : Input parameters accept *args and **kwargs instead of specify every parameter in order to allow Backrefs to work even when the Re or Regex API changes. Change was made to support new Regex timeout parameter.","title":"4.1"},{"location":"about/changelog/#402","text":"FIX : Fix compatibility issues with latest Regex versions.","title":"4.0.2"},{"location":"about/changelog/#401","text":"FIX : Ensure that when generating the Unicode property tables, that the property files are read in with UTF-8 encoding.","title":"4.0.1"},{"location":"about/changelog/#40","text":"NEW : Drop support for new features in Python 2. Python 2 support is limited to the 3.X.X series and will only receive bug fixes up to 2020. All new features moving forward will be on the 4.X.X series and will be for Python 3+ only.","title":"4.0"},{"location":"about/changelog/#36","text":"NEW : Make version available via the new, and more standard, __version__ attribute and add the __version_info__ attribute as well. Deprecate the old version and version_info attribute for future removal.","title":"3.6"},{"location":"about/changelog/#352","text":"FIX : Include zip for Unicode 11 (Python 3.7) to make installation more reliable.","title":"3.5.2"},{"location":"about/changelog/#351","text":"FIX : POSIX character classes should not be part of a range. FIX : Replace string casing logic properly follows other implementations like Boost etc. \\L , \\C , and \\E should all terminate \\L , and \\C . \\l and \\c will be ignored if followed by \\C or \\L .","title":"3.5.1"},{"location":"about/changelog/#35","text":"NEW : Use a more advanced format string implementation that implements all string features, included those found in format_spec . FIX : Relax validation so not to exclude valid named Unicode values. FIX : Caching issues where byte string patterns were confused with Unicode patterns. FIX : More protection against using conflicting string type combinations with search and replace.","title":"3.5"},{"location":"about/changelog/#34","text":"NEW : Add support for generic line breaks ( \\R ) to Re. NEW : Add support for an overly simplified form of grapheme clusters ( \\X ) to Re. Roughly equivalent to (?>\\PM\\pM*) . NEW : Add support for Vertical_Orientation property for Unicode 10.0.0 on Python 3.7.","title":"3.4"},{"location":"about/changelog/#33","text":"NEW : Add support for Indic_Positional_Category \\ Indic_Matra_Category and Indic_Syllabic_Category properties.","title":"3.3"},{"location":"about/changelog/#321","text":"FIX : Bidi_Paired_Bracket_type property's None value should be equivalent to all characters that are not open or close characters.","title":"3.2.1"},{"location":"about/changelog/#32","text":"NEW : Add support for Script_Extensions Unicode properties (Python 3 only as Python 2, Unicode 5.2.0 does not define these). Can be accessed via \\p{scripts_extensions: kana} or \\p{scx: kana} . NEW : When defining scripts with just their name \\p{Kana} , use Script_Extensions instead of Scripts . To get Scripts results, you must specify \\p{scripts: kana} or \\p{sc: scripts} . NEW : Add Bidi_Paired_Bracket_Type Unicode property (Python 3.4+ only). NEW : Add support for IsBinary for binary properties: \\p{IsAlphabetic} == \\p{Alphabetic: Y} . FIX : Tweaks/improvements to string iteration.","title":"3.2"},{"location":"about/changelog/#312","text":"FIX : Properly escape any problematic characters in Unicode tables.","title":"3.1.2"},{"location":"about/changelog/#311","text":"FIX : bregex.compile now supports additional keyword arguments for named lists like bregex.compile_search does.","title":"3.1.1"},{"location":"about/changelog/#31","text":"NEW : Start and end word boundary back references are now specified with \\m and \\M like Regex does. \\< and \\> have been removed from Regex. FIX : Escaped \\< and \\> are no longer processed as Re is known to escape these in versions less than Python 3.7.","title":"3.1"},{"location":"about/changelog/#305","text":"FIX : Process non raw string equivalent escaped Unicode on Python 2.7. FIX : Compiled objects should return the pattern string, not the pattern object via the property pattern .","title":"3.0.5"},{"location":"about/changelog/#304","text":"FIX : Formally enable Python 3.7 support. FIX : Tweak to Unicode wide character handling.","title":"3.0.4"},{"location":"about/changelog/#303","text":"FIX : Compiled search and replace objects should be hashable. FIX : Handle cases where a new compiled pattern object is passed back through compile functions.","title":"3.0.3"},{"location":"about/changelog/#302","text":"FIX : Bregex purge was calling Re's purge instead of Regex's purge.","title":"3.0.2"},{"location":"about/changelog/#301","text":"FIX : Do not accidentally \\. as a group in replace strings (don't use isdigit string method). FIX : Group names can start with _ in replace strings. FIX : Do not rely on Re for parsing string. FIX : Match behavior in \\g<group> parsing better. FIX : Raise some exceptions in a few places we weren't.","title":"3.0.1"},{"location":"about/changelog/#30","text":"NEW : Added new compile function that returns a pattern object that feels like Re's and Regex's pattern object. NEW : Add some caching of search and replace patterns. NEW : Completely refactored algorithm for search and replace pattern augmentation. NEW : Add support for \\e for escape character \\x1b in both Re and Regex. NEW : Add support for \\R for generic newlines in the Regex module (Regex only). NEW : Support Unicode property form \\pP and \\PP . NEW : Add support for properly handling per group, scoped verbose flags in the preprocess step (Regex). NEW : Handle (?#comments) properly in the preprocess step. NEW : Add support for \\N in byte strings (characters out of range won't be included). NEW : Add support for \\p and \\P in byte strings (characters out of range won't be included). NEW : Add support for \\< and \\> word boundary escapes. FIX : Missing block properties on narrow systems when the property starts beyond the narrow limit. FIX : Fix issue where an invalid general category could sometimes pass and return no characters. FIX : Fix \\Q...\\E behavior so it is applied first as a separate step. No longer avoids \\Q...\\E in things like character groups or comments. FIX : Flag related parsing issues in Regex and Re Python 3.6+.","title":"3.0"},{"location":"about/changelog/#22","text":"NEW : Proper support for \\N{Unicode Name} . FIX : Incomplete escapes will not be passed through, but will instead throw an error. For instance \\p should only be passed through if it is complete \\p{category} . Python 3.7 will error on this if we pass it through, and Python 3.6 will generate warnings. We should just consistently fail on it for all Python versions.","title":"2.2"},{"location":"about/changelog/#21","text":"NEW : Handle Unicode and byte notation in Re replace templates. NEW : Rework algorithm to handle replace casing back references in Python 3.7 development builds in preparation for Python 3.7 release. NEW : Add support for case back references when using the Regex module's subf and subfn . NEW : Add new convenience method expandf to Regex that can take a format string and apply format style replaces. NEW : Add FORMAT flag to compile_replace to apply format style replaces when applicable. NEW : Add the same support that Regex has in relation to format style replacements to Re. NEW : Compiled replacements are now immutable. NEW : Various logic checking proper types and values. FIX : Fix octal/group logic in Regex and Re. FIX : Fix issue dealing with trailing backslashes in replace templates.","title":"2.1"},{"location":"about/changelog/#20","text":"NEW : First attempt at bringing Python 3.7 support, fixing back reference logic, and adding new back reference. Released and then removed due to very poor behavior.","title":"2.0"},{"location":"about/changelog/#102","text":"FIX : Issues related to downloading Unicode data and Unicode table generation. Include Unicode data in release.","title":"1.0.2"},{"location":"about/changelog/#101","text":"FIX : Fixes for Python 3.6.","title":"1.0.1"},{"location":"about/changelog/#10","text":"NEW : Initial release.","title":"1.0"},{"location":"about/contributing/","text":"Contributing & Support Overview Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests. Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. GitHub Sponsors If you'd like to do a one time contribution, you can do so via PayPal. PayPal Bug Reports Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Pull Requests Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Feel free to use a virtual environment if you are concerned about installing any of the Python packages. Running Validation Tests Make sure that Tox is installed: pip install tox Run Tox: tox Tox should install necessary dependencies and run the tests. Documentation Improvements A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#overview","text":"Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests.","title":"Overview"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. GitHub Sponsors If you'd like to do a one time contribution, you can do so via PayPal. PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Feel free to use a virtual environment if you are concerned about installing any of the Python packages.","title":"Pull Requests"},{"location":"about/contributing/#running-validation-tests","text":"Make sure that Tox is installed: pip install tox Run Tox: tox Tox should install necessary dependencies and run the tests.","title":"Running Validation Tests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Documentation Improvements"},{"location":"about/license/","text":"License MIT license. Copyright \u00a9 2015 - 2021 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT license. Copyright \u00a9 2015 - 2021 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}