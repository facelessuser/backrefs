{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":""},{"location":"#overview","title":"Overview","text":"<p>Backrefs is a wrapper around Python's built-in Re and the 3rd party Regex library.  Backrefs adds various additional back references (and a couple other features) that are known to some regular expression engines, but not to Python's Re and/or Regex.  The supported references actually vary depending on the regular expression engine being used as the engine may already have support for some, or things that prevent implementation of a feature.</p> <p>Backrefs comes in two flavors: <code>bre</code> (a Re wrapper) and <code>bregex</code> (a Regex wrapper).</p>"},{"location":"#installation_1","title":"Installation","text":"<p>There are a couple of recommended ways to install Backrefs.</p> <ol> <li> <p>Install with pip:</p> <pre><code>$ pip install backrefs\n</code></pre> </li> <li> <p>Install with optional requirement <code>regex</code>:</p> <pre><code>$ pip install backrefs[extras]\n</code></pre> </li> <li> <p>Install locally from source via:</p> <pre><code>$ python setup.py build\n$ python setup.py install\n</code></pre> </li> <li> <p>If developing Backrefs, you can install via:</p> <pre><code>$ pip install --editable .\n</code></pre> <p>This method will allow you to instantly see your changes without reinstalling which is great for developing.</p> </li> </ol>"},{"location":"refs/","title":"Supported References","text":""},{"location":"refs/#search-back-references","title":"Search Back References","text":"<p>Re and Regex out of the box have very different feature sets. Backrefs tailors the supported features for each regular expression engine. For instance, Regex already supports Unicode properties, so Backrefs does not attempt to provide such support.</p>"},{"location":"refs/#re","title":"Re","text":"<p>LOCALE and Character Properties</p> <p>Backrefs does not consider <code>LOCALE</code> when inserting POSIX or Unicode properties. When forced int ASCII mode, either by  the <code>ASCII</code> (or <code>LOCALE</code>) flag or when operating on a byte string, Unicode properties are restricted to the ASCII range.</p> Back\u00a0References Description <code>\\e</code> Deprecated: Use <code>\\x1b</code> instead. Escape character <code>\\x1b</code>. <code>\\Q...\\E</code> Quotes (escapes) text for regular expression.  <code>\\E</code> signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. <code>\\p{UnicodeProperty}</code> Unicode property character class. Can be used in character classes <code>[]</code>. See Unicode Properties for more info. <code>\\pX</code> Unicode property character class where <code>X</code> is the uppercase letter that represents the General Category property.  For instance, <code>\\pL</code> would be equivalent to <code>\\p{L}</code> or <code>\\p{Letter}</code>. <code>\\P{UnicodeProperty}</code> Inverse Unicode property character class. Can be used in character classes <code>[]</code>. See Unicode Properties for more info. <code>\\PX</code> Inverse Unicode property character class where <code>X</code> is the uppercase letter that represents the General Category property. For instance, <code>\\PL</code> would be equivalent to <code>\\P{L}</code> or <code>\\P{Letter}</code>. <code>[[:alnum:]]</code> Though not really a back reference, support for POSIX style character classes is available. See POSIX Style Properties for more info. <code>\\N{UnicodeName}</code> Named characters are are normally ignored in Re, but Backrefs adds support for them. <code>\\m</code> Start word boundary. Translates to <code>\\b(?=\\w)</code>. <code>\\M</code> End word boundary. Translates to <code>\\b(?&lt;=\\w)</code>. <code>\\h</code> Deprecated: Use <code>\\p{Horiz_Space}</code> instead. Horizontal whitespace. Equivalent to using <code>[[:blank:]]</code> or <code>[\\t\\p{Zs}]</code>. <code>\\R</code> Generic line breaks. This will use the pattern <code>(?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85\\u2028\\u2029])</code> which is roughly equivalent the to atomic group form that other engines use: <code>(?&gt;\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029])</code>. When applied to byte strings, the pattern <code>(?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85])</code> will be used. <code>\\X</code> Grapheme clusters. This will use the pattern <code>(?:\\PM\\pM*(?!\\pM))</code> which is roughly equivalent to the atomic group form that other engines have used in the past:  <code>(?&gt;\\PM\\pM*)</code>. This does not implement full, proper grapheme clusters like the 3rd party Regex module does as this would require changes to the Re core engine. <p>Deprecated 6.0</p> <p><code>\\e</code> and <code>\\h</code> have both been deprecated in 6.0. Please migrate to using <code>\\x1b</code> and <code>\\p{Horiz_Space}</code> in their places respectively.</p>"},{"location":"refs/#regex","title":"Regex","text":"<p>Note</p> <p>Regex already natively supports <code>\\p{...}</code>, <code>\\P{...}</code>, <code>\\pX</code>, <code>\\PX</code>, <code>\\N{...}</code>, <code>\\X</code>, <code>\\h</code>, <code>\\m</code>, and <code>\\M</code> so Backrefs does not attempt to add this to search patterns.</p> Back\u00a0References Description <code>\\e</code> Deprecated: Use <code>\\x1b</code> instead. Escape character <code>\\x1b</code>. <code>\\Q...\\E</code> Quotes (escapes) text for regular expression.  <code>\\E</code> signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. <code>\\R</code> Generic line breaks. When searching a Unicode string, this will use the pattern <code>(?&gt;\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029])</code>, and when applied to byte strings, the pattern <code>(?&gt;\\r\\n|[\\n\\v\\f\\r\\x85])</code> will be used. <p>Deprecated 6.0</p> <p><code>\\e</code> has been deprecated in 6.0. Please migrate to using <code>\\x1b</code> in its place.</p>"},{"location":"refs/#replace-back-references","title":"Replace Back References","text":"<p>The replace back references below apply to both Re and Regex and are essentially non-specific to the regular expression engine being used.  Casing is applied to both the literal text and the replacement groups within the replace template.  In most cases you'd only need to wrap the groups, but it may be useful to apply casing to the literal portions if you are dynamically assembling replacement patterns.</p> <p>LOCALE and Casing</p> <p><code>LOCALE</code> is not considered when applying character casing. Unicode casing is applied in Unicode strings and ASCII casing is applied to byte strings.</p> Back\u00a0References Description <code>\\c</code> Uppercase the next character. <code>\\l</code> Lowercase the next character. <code>\\C...\\E</code> Apply uppercase to all characters until either the end of the string, the end marker <code>\\E</code> is found, or another <code>\\C</code> or <code>\\L</code> is encountered. <code>\\L...\\E</code> Apply lowercase to all characters until either the end of the string, the end marker <code>\\E</code> is found, or another <code>\\L</code> or <code>\\C</code> is encountered. <code>\\U</code> Wide Unicode character <code>\\U00000057</code>. Re doesn't translate this notation in raw strings (<code>r\"...\"</code>), and Regex doesn't in format templates in raw strings (<code>r\"{} {}\"</code>).  This adds support for them. <code>\\u</code> Narrow Unicode character <code>\\u0057</code>. Re doesn't translate this notation in raw strings (<code>r\"...\"</code>), and Regex doesn't in format templates in raw strings (<code>r\"{} {}\"</code>).  This adds support for them. <code>\\x</code> Byte character <code>\\x57</code>. Re doesn't translate this notation in raw strings (<code>r\"...\"</code>), and Regex doesn't in format templates in raw strings (<code>r\"{} {}\"</code>).  This adds support for them. <code>\\N{UnicodeName}</code> Named characters are are normally ignored in Re, but Backrefs adds support for them. <p>Tip</p> <p>Complex configurations of casing should work fine.</p> <ul> <li><code>\\L\\cTEST\\E</code> \u2192 <code>Test</code></li> <li><code>\\c\\LTEST\\E</code> \u2192 <code>test</code></li> <li><code>\\L\\cTEST \\cTEST\\E</code> \u2192 <code>Test Test</code></li> </ul>"},{"location":"refs/#unicode-properties","title":"Unicode Properties","text":"<p>New in 5.0</p> <p>5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the <code>ASCII</code> flag along with more extensive testing and bug fixes.</p> <p>A number of various Unicode properties are supported in Backrefs, but only for Re as Regex already has its own implementation of Unicode properties. Some properties may not be available on certain Python versions due to the included Unicode build.</p> <p>It is important to note that Backrefs handles Unicode properties by transforming them to character classes with all the associated characters: <code>\\p{Cs}</code> \u2192 <code>[\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]</code>.  Because of this, Backrefs can create really large regular expressions that the underlying engine must walk through.  In short, Re with Backrefs will never be as efficient or fast as using Regex's Unicode properties, but it is very useful when you need or want to use Re.</p> <p>Also, keep in mind that there are most likely some differences between Regex's Unicode Properties and Backrefs' Unicode properties. One notable difference is Regex does not currently implement <code>script_extensions</code> while Backrefs' does and uses them as the default when specifying them in the form <code>\\p{IsScriptValue}</code>  or <code>\\p{ScriptValue}</code> just like Perl does. See Property Short Names for more info.</p> Supported\u00a0Properties Aliases <code>Age</code> <code>Bidi_Class</code> <code>bc</code> <code>Bidi_Paired_Bracket_Type</code> <code>bpt</code> <code>Binary</code> <code>Block</code> <code>blk</code> <code>Canonical_Combining_Class</code> <code>ccc</code> <code>Decomposition_Type</code> <code>dt</code> <code>East_Asian_Width</code> <code>ea</code> <code>General_Category</code> <code>gc</code> <code>Grapheme_Cluster_Break</code> <code>gcb</code> <code>Hangul_Syllable_Type</code> <code>hst</code> <code>Indic_Positional_Category</code> <code>inpc</code> <code>Indic_Syllabic_Category</code> <code>insc</code> <code>Joining_Group</code> <code>jg</code> <code>Joining_Type</code> <code>jt</code> <code>Line_Break</code> <code>lb</code> <code>NFC_Quick_Check</code> <code>nfcqc</code> <code>NFD_Quick_Check</code> <code>nfdqc</code> <code>NFKC_Quick_Check</code> <code>nfkcqc</code> <code>NFKD_Quick_Check</code> <code>nfkdqc</code> <code>Numeric_Type</code> <code>nt</code> <code>Numeric_Value</code> <code>nv</code> <code>Script</code> <code>sc</code> <code>Script_Extensions</code> <code>scx</code> <code>Sentence_Break</code> <code>sb</code> <code>Vertical_Orientation</code>\u00a0(Python\u00a03.7+) <code>vt</code> <code>Word_Break</code> <code>wb</code> <p>Note</p> <p>The Binary property is not actually a property, but more a type of Unicode property.  The available binary properties may differ from Unicode version to Unicode version.</p> <p>New 4.4.0</p> <p>Python 3.9 now uses Unicode 13, and with that comes various new binary properties: <code>emoji</code>, <code>emojicomponent</code>, <code>emojimodifier</code>, <code>emojimodifierbase</code>, and <code>emojipresentation</code>. Associated aliases are also included: <code>ecomp</code>, <code>emod</code>, <code>ebase</code>, and <code>epres</code>.</p> <p>Exhaustive documentation on all these properties and their values is not currently provided. In general, we'll cover the syntax rules, and special short name handling to those rules for specific properties. Though we will outline all the values for General Category, we will not outline all of the valid values for the other properties. You can look at Perl's Unicode property documentation to get an idea of what values are appropriate for a given property, but keep in mind, syntax may vary from Perl's syntax.</p> <p>Unicode properties are specific to search patterns and can be used to specify a request to match all the characters in a specific Unicode property. Unicode properties can be used in byte strings, but the patterns will be restricted to the ASCII range.</p> <p>Additionally, Unicode properties are sensitive to the <code>ASCII</code> flag and will have their range limited to ASCII if used. The <code>LOCALE</code> flag is treated as <code>ASCII</code> in relation to Unicode properties.</p>"},{"location":"refs/#syntax","title":"Syntax","text":"<p>Unicode properties can be specified with the format: <code>\\p{property=value}</code>, <code>\\p{property:value}</code>. You can also do inverse properties by using the <code>^</code> character (<code>\\p{^property=value}</code>) or by using a capital <code>P</code> (<code>\\P{property=value}</code> or <code>\\P{property:value}</code>).</p> <p>Unicode properties may only have one property specified between the curly braces.  If you want to use multiple properties to capture a singe character, create a character class: <code>[\\p{UnicodeProperty}\\p{OtherUnicodeProperty}]</code>.</p> <p>When specifying a property, the property and value matching is case insensitive and characters like <code>[ -_]</code> will be stripped out.  So the following are all equivalent: <code>\\p{Uppercase_Letter}</code>, <code>\\p{Uppercase-letter}</code>, <code>\\p{UPPERCASELETTER}</code>, <code>\\p{upper case letter}</code>.</p> <p>There are a number of binary properties. In general, binary properties are specified by stating the binary property and a boolean value. True values can be <code>Yes</code>, <code>Y</code>, <code>True</code>, or <code>T</code>. False values can be <code>No</code>, <code>N</code>, <code>False</code>, or <code>F</code>. For example, to specify characters that are \"alphabetic\", we can use <code>\\p{Alphabetic: Y}</code>. To specify characters that are not \"alphabetic\": <code>\\p{Alphabetic: N}</code>.</p> <p>New 5.4 Custom Binary properties</p> <p>In 5.4, the new custom binary properties <code>Vert_space</code> and <code>Horiz_Space</code> were added.</p>"},{"location":"refs/#property-short-names","title":"Property Short Names","text":"<p>General Category, Script Extensions, Blocks, and Binary all can be specified in a short form using just their name or alias: <code>\\p{value}</code>, but they will be evaluated in the following order to resolve name conflicts as some the same value that is used in Script may be used in Blocks etc.</p> <ol> <li>General Category</li> <li>Script Extensions</li> <li>Binary</li> <li>Blocks</li> </ol> <p>Script Extensions and Binary properties can also be defined in the format <code>IsValue</code>.  For instance, if we wanted to match characters in the <code>Latin</code> script, we could use the syntax <code>\\p{IsLatin}</code>, which would be the same as <code>\\p{Latin}</code> or <code>\\p{scx: Latin}</code>.  For Binary properties, <code>\\p{IsAlphabetic}</code> is the same as <code>\\p{Alphabetic: Y}</code> or <code>\\p{Alphabetic}</code>.</p> <p>Block properties have a similar short form as Script and Binary properties.  For Blocks you can use <code>InValue</code> to specify a block. If we wanted to match characters in the <code>Basic_Latin</code> block, we could use the syntax <code>\\p{InBasic_Latin}</code>. This would be the same as <code>\\p{Block: Basic_Latin}</code> or <code>\\p{Basic_Latin}</code>.</p> <p>/// warn | Short Name Conflicts When it comes to short names, each new Unicode version, there is a risk that new properties could cause conflicts with existing names and/or aliases. Currently, most of the conflicts involve the Block properties. To reduce friction, they are evaluated last.</p> <p>Generally, it is discouraged to use short names for Block properties. But the option is still supported, but Block  properties will be evaluated last. There are currently no known conflicts with <code>In*</code> properties, but in future Unicode versions there could.</p> <p>As for short names for scripts, Binary, or General Categories, there is always the possibility that these could break in the future as well. Generally, more explicit is better and probably safer. ///</p> <p>Lastly, you can specify general category properties in the form <code>\\pX</code> where <code>X</code> is the single letter terse property form. In this form, you can only use the single character values. So you could specify <code>Letter</code>, whose terse form is <code>L</code> with <code>\\pL</code>, but cannot specify <code>Cased_Letter</code> which has a terse form of <code>Lc</code>.</p> <p>See the table below to see all the Unicode General Category values and their terse forms.</p> Verbose\u00a0Property\u00a0Form Terse\u00a0Property\u00a0Form <code>Other</code> <code>C</code> <code>Control</code> <code>Cc</code> <code>Format</code> <code>Cf</code> <code>Surrogate</code> <code>Cs</code> <code>Private_Use</code> <code>Co</code> <code>Unassigned</code> <code>Cn</code> <code>Letter</code> <code>L</code> <code>Cased_Letter</code> <code>L&amp;</code> or <code>Lc</code> <code>Uppercase_Letter</code> <code>Lu</code> <code>Lowercase_Letter</code> <code>Ll</code> <code>Titlecase_Letter</code> <code>Lt</code> <code>Modifier_Letter</code> <code>Lm</code> <code>Other_Letter</code> <code>Lo</code> <code>Mark</code> <code>M</code> <code>Nonspacing_Mark</code> <code>Mc</code> <code>Spacing_Mark</code> <code>Me</code> <code>Enclosing_Mark</code> <code>Md</code> <code>Number</code> <code>N</code> <code>Decimal_Number</code> <code>Nd</code> <code>Letter_Number</code> <code>Nl</code> <code>Other_Number</code> <code>No</code> <code>Punctuation</code> <code>P</code> <code>Connector_Punctuation</code> <code>Pc</code> <code>Dash_Punctuation</code> <code>Pd</code> <code>Open_Punctuation</code> <code>Ps</code> <code>Close_Punctuation</code> <code>Pe</code> <code>Initial_Punctuation</code> <code>Pi</code> <code>Final_Punctuation</code> <code>Pf</code> <code>Other_Punctuation</code> <code>Po</code> <code>Symbol</code> <code>S</code> <code>Math_Symbol</code> <code>Sm</code> <code>Currency_Symbol</code> <code>Sc</code> <code>Modifier_Symbol</code> <code>Sk</code> <code>Other_Symbol</code> <code>So</code> <code>Separator</code> <code>Z</code> <code>Space_Separator</code> <code>Zs</code> <code>Line_Separator</code> <code>Zl</code> <code>Paragraph_Separator</code> <code>Z</code>"},{"location":"refs/#posix-style-properties","title":"POSIX Style Properties","text":"<p>New in 5.0</p> <p>5.0 brings significant improvements and bug fixes to Unicode property handling. Properties are sensitive to the <code>ASCII</code> flag along with more extensive testing and bug fixes. Additionally, POSIX style properties are now just an extension of normal Unicode properties. All the POSIX names are available and now conform to the Unicode specification for POSIX compatibility. Read on to learn more.</p> <p>Backrefs allows for POSIX style properties in the form <code>[:name:]</code>. These properties can only be used inside character classes and are another form for expressing Unicode properties. Any Unicode property that can be expressed via the <code>\\p{name}</code> form can also be expressed in the <code>[:name:]</code> form. To illustrate, the following are all the same:</p> <ul> <li><code>[[:upper:]]</code> == <code>[\\p{upper}]</code></li> <li><code>[[:^upper:]]</code> == <code>[\\p{^upper}]</code></li> <li><code>[[:alpha=yes:]]</code> == <code>[\\p{alpha=yes}]</code></li> </ul> <p>A number of POSIX property names are available via compatibility properties as outlined in the Unicode specification for POSIX compatibility. These properties will operate in the Unicode range and the ASCII range depending on the regular expression mode. These patterns, like all Unicode properties, are sensitive to the <code>ASCII</code> flag (or <code>LOCALE</code> which will treat them as <code>ASCII</code>).</p> <p>It is important to note that whether used in the form <code>[[:name:]]</code> or <code>\\p{name}</code>, each POSIX name is available both with and without the <code>posix</code> prefix, but it is recommended to use the <code>posix</code> prefix to get the POSIX definition of the pattern as number of patterns have both a POSIX and Unicode definition that differ. The Unicode specification for POSIX compatibility outlines all the POSIX compatible properties and the ones which have dual definitions: <code>punct</code>, <code>alnum</code>, <code>digit</code>, and <code>xdigit</code> all have a Unicode standard and a POSIX compatibility variant and must be accessed with the <code>posix</code> prefix to get the POSIX form.</p> <p>In the table below, patterns with <code>--</code> mean <code>[[in this] -- [but not this]]</code>.</p> [:posix:] \\p{Posix} ASCII Unicode <code>alpha</code> <code>Alpha</code> <code>[a-zA-Z]</code> <code>\\p{Alphabetic}</code> <code>alnum</code> <code>PosixAlnum</code> <code>[[:alpha:][:digit:]]</code> <code>[[:alpha:][:digit:]]</code> <code>blank</code> <code>Blank</code> <code>[ \\t]</code> <code>[\\p{Zs}\\t]</code> <code>cntrl</code> <code>Cntrl</code> <code>[\\x00-\\x1F\\x7F]</code> <code>\\p{Cc}</code> <code>digit</code> <code>PosixDigit</code> <code>[0-9]</code> <code>[0-9]</code> <code>graph</code> <code>Graph</code> <code>[^ [:cntrl:]]</code> <code>[^[:space:][:cntrl:]\\p{Cn}\\p{Cs}]</code> <code>lower</code> <code>Lower</code> <code>[a-z]</code> <code>[\\p{Lowercase}]</code> <code>print</code> <code>Print</code> <code>[[:graph:] ]</code> <code>[[\\p{P}\\p{S}]--[\\p{alpha}]]</code> <code>punct</code> <code>PosixPunct</code> <code>[!\\\"\\#$%&amp;'()*+,\\-./:;&amp;lt;=&amp;gt;?@\\[\\\\\\]^_`{}~]</code> <code>[[[:graph:][:blank:]]--[[:cntrl:]]]</code> <code>space</code> <code>Space</code> <code>[ \\t\\r\\n\\v\\f]</code> <code>[\\p{Whitespace}]</code> <code>upper</code> <code>Upper</code> <code>[A-Z]</code> <code>[\\p{Uppercase}]</code> <code>xdigit</code> <code>PosixXDigit</code> <code>[A-Fa-f0-9]</code> <code>[A-Fa-f0-9]</code>"},{"location":"refs/#compatibility-properties","title":"Compatibility Properties","text":"<p>New in 5.0</p> <p>While many of the properties were available before 5.0, <code>word</code> is newly available. And all the properties now conform to the Unicode specification for POSIX compatibility.</p> <p>Unicode specification for POSIX compatibility defines a number of properties, many of which double as Posix properties. These properties can be accessed via <code>\\p{name}</code> or <code>[[:name:]]</code>.</p> <p>In the table below, patterns with <code>--</code> mean <code>[[in this] -- [but not this]]</code>.</p> \\p{Posix} Unicode <code>Alpha</code> <code>\\p{Alphabetic}</code> <code>Alnum</code> <code>[\\p{Alpha}\\p{Digit}]</code> <code>Blank</code> <code>[\\p{Zs}\\t]</code> <code>Cntrl</code> <code>\\p{Cc}</code> <code>Digit</code> <code>\\p{Nd}</code> <code>Graph</code> <code>[^\\p{Space}\\p{Cntrl}\\p{Cn}\\p{Cs}]</code> <code>Lower</code> <code>\\p{Lowercase}</code> <code>Print</code> <code>[[\\p{P}\\p{S}]--[\\p{Alpha}]]</code> <code>Punct</code> <code>\\p{P}</code> <code>Space</code> <code>\\p{Whitespace}</code> <code>Upper</code> <code>\\p{Uppercase}</code> <code>Word</code> <code>[\\p{Alnum}\\p{M}\\p{Pc}\\p{JoinControl}]</code> <code>XDigit</code> <code>[\\p{Nd}\\p{HexDigit}]</code>"},{"location":"usage/","title":"Introduction","text":""},{"location":"usage/#importing","title":"Importing","text":"<p>Backrefs comes in two flavors: <code>bre</code> (a Re wrapper) and <code>bregex</code> (a Regex wrapper). You can import either one simply by importing it from the <code>backrefs</code> library. Regex must be installed if using <code>bregex</code>.</p> <pre><code>from backrefs import bre\nfrom backrefs import bregex\n</code></pre>"},{"location":"usage/#searches","title":"Searches","text":"<p>Backrefs preprocesses search patterns looking for new syntax that it replaces with compatible regular expressions for the given regular expression engine. For instance, Backrefs implements the <code>\\h</code> reference in Re, and when compiled, we get an Re object with a regular expression pattern that captures horizontal whitespace characters:</p> <pre><code>&gt;&gt;&gt; bre.compile('\\h')\nbackrefs.bre.Bre(re.compile('[\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000]'), auto_compile=True)\n</code></pre> <p>It can be seen that the Backrefs object is simply wrapped around an Re compiled pattern, and we see that <code>\\h</code> was replaced with <code>[\\t \\xa0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000]</code>.</p> <p>This basic approach is used to implement all sorts of references from Unicode properties:</p> <pre><code>&gt;&gt;&gt; bre.compile(r'test \\p{Cs}')\nbackrefs.bre.Bre(re.compile('test [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]'), auto_compile=True)\n</code></pre> <p>To start and end word boundaries:</p> <pre><code>&gt;&gt;&gt; bre.compile(r'\\mtest\\M')\nbackrefs.bre.Bre(re.compile('\\\\b(?=\\\\w)test\\\\b(?&lt;=\\\\w)'), auto_compile=True)\n</code></pre> <p>A compiled Backrefs object has all the same functions as the regular expression's object, so you can use it in the same way to perform splits, matches, substitutions, and anything else.</p>"},{"location":"usage/#replacements","title":"Replacements","text":"<p>Replace templates are a little different than search patterns and require a bit more control to accomplish some of the replace features which is why a Backrefs object is wrapped around the returned Re object. The wrapper mirrors the regular expression object's shadows so that it can intercept the calls to <code>sub</code>, <code>subn</code>, etc. to process replacements before passing them to the regular expression engine.</p> <p>Like with searches, Backrefs preprocesses the replace string before passing it to the regular expression engine. Once Backrefs has parsed and altered the string as needed, it is then passed to the regular expression engine with the compiled search pattern to extract string literals and the group mapping. With this, Backrefs can assemble the replacement and inject new functionality on substitution.</p> <p>For instance, here we use the start and end markers of <code>\\C</code> and <code>\\E</code> to specify that the content in between should be capitalized. Traditionally, <code>\\U</code> and <code>\\E</code> is used, but since <code>\\U</code> is a Unicode escape in Python, we chose to use <code>\\C</code>.</p> <pre><code>&gt;&gt;&gt; pattern = bre.compile(r'(\\p{Letter}+)')\n&gt;&gt;&gt; pattern.sub(r'\\C\\1\\E', 'sometext')\n'SOMETEXT'\n</code></pre>"},{"location":"usage/#format-replacements","title":"Format Replacements","text":"<p>Backrefs allows for replacement string templates to use a format string format in both Re and Regex. This feature is a Regex library specific feature that we mimic in Re, but enhance in both.</p> <p>Originally, this feature was developed in Regex to allow accessing specific captures of a group when multiple captures are made. For Regex, this makes a lot of sense as the library actually tracks all captures for a group. Each capture can be indexed individually using the format string format.</p> <pre><code>&gt;&gt;&gt; regex.subf(r\"(?:(\\w+) ){2}(\\w+)\", \"{0} =&gt; {1[0]} {1[1]} {2}\", \"foo bar baz\")\n'foo bar baz =&gt; foo bar baz'\n&gt;&gt;&gt; regex.subf(r\"(?:(?P&lt;word1&gt;\\w+) ){2}(?P&lt;word2&gt;\\w+)\", \"{0} =&gt; {word1[0]} {word1[1]} {word2}\", \"foo bar baz\")\n'foo bar baz =&gt; foo bar baz'\n</code></pre> <p>The Re engine does not track multiple captures for a single group \u2013 something we cannot change \u2013 and instead only captures the last capture. Format strings in Re will only provide the last capture in Re. If you were to try and index into different captures instead of accepting the default, you will only be able to reference the last one. If at some point in the future, Re begins to track all captures, then this feature will be updated to reflect such changes.</p> <pre><code>&gt;&gt;&gt; bre.subf(r\"(?:(\\w+) ){2}(\\w+)\", \"{0} =&gt; {1[0]} {1[-1]} {2}\", \"foo bar baz\")\n'foo bar baz =&gt; bar bar baz'\n</code></pre> <p>While Re does not really expose multiple captures, this doesn't mean the format string is of no use to Re. For one, the format string syntax may be generally preferred as a less cumbersome format for specifying groups by index or by name. By default, Python's Re requires groups to be specified via <code>\\1</code> or <code>\\g&lt;name&gt;</code>, while the format syntax simply requires   <code>{1}</code> or <code>{name}</code>. Escaping braces is the same as in any format string and requires the user to use two <code>{{</code> or <code>}}</code>.</p> <p>When using Backrefs' format replace, it should feel similar to Regex's format replace, except you will generally use raw strings to allow for back slash references.</p> <pre><code>&gt;&gt;&gt; bregex.subf(r\"(\\w+) (\\w+)\", r\"{0} =&gt; {2} {1}\", \"foo bar\")\n'foo bar =&gt; bar foo'\n&gt;&gt;&gt; bregex.subf(r\"(?P&lt;word1&gt;\\w+) (?P&lt;word2&gt;\\w+)\", r\"{word2} {word1}\", \"foo bar\")\n'bar foo'\n</code></pre> <p>You can index into groups that have multiple captures, and while it works for both Re and Regex, it is only useful when using <code>bregex</code>.</p> <pre><code>&gt;&gt;&gt; bregex.subf(r\"(\\w)+ (\\w+)\", \"{0} =&gt; {2} {1[0]}\", \"foo bar\")\n'foo bar =&gt; bar f'\n</code></pre> <p>You can also use <code>{} {}</code> which is the same as <code>{0} {1}</code>.</p> <pre><code>&gt;&gt;&gt; bre.subf(r\"(\\w+) (\\w+)\", r\"{} =&gt; \\C{} {}\\E\", \"foo bar\")\n'foo bar =&gt; FOO BAR'\n</code></pre> <p>Backrefs also provides an <code>expand</code> variant for format templates called <code>expandf</code>.</p> <pre><code>&gt;&gt;&gt; pattern = bre.compile_search(r\"(\\w+) (\\w+)\")\n&gt;&gt;&gt; m = pattern.match('foo bar')\n&gt;&gt;&gt; bre.expandf(m, r\"{0} =&gt; {2} {1}\")\n'foo bar =&gt; bar foo'\n</code></pre>"},{"location":"usage/#enhancements","title":"Enhancements","text":"<p>Backrefs' implementation is a little different than Regex's default implementation. Below we cover what is different and why.</p> <ol> <li> <p>Regex's original implementation is very much like it's non-format style replacement accept for two differences: you     can access individual captures and you cannot use Python string back references such as specifying Unicode via     <code>\\u&lt;code&gt;</code>, etc. In Backrefs, we've enhanced the syntax \u2013 for both Re and Regex \u2013 to allow back references to work     along side brace replacements. This means you can use string back references and and built-in Backrefs features like     <code>\\C...\\E</code> or <code>\\L...\\E</code>.</p> <pre><code>&gt;&gt;&gt; bre.subf(r\"(\\w+) (\\w+)\", r\"{0} =&gt; \\C{2} {1}\\E\", \"foo bar\")\n'foo bar =&gt; BAR FOO'\n&gt;&gt;&gt; bregex.subf(r\"(\\w+) (\\w+)\", r\"{0} =&gt; \\C{2} {1}\\E\", \"foo bar\")\n'foo bar =&gt; BAR FOO'\n</code></pre> </li> <li> <p>The second enhancement that Backrefs adds is the ability to use format string alignment features. In the following     example, we center the replacement and pad it out to 8 characters using <code>|</code> for the padding. We also use casing     references (<code>\\C...\\E</code>) to capitalize the replacement group.</p> <pre><code>&gt;&gt;&gt; bregex.subf(r'(test)', r'\\C{0:|^8}\\E', 'test')\n'||TEST||'\n</code></pre> <p>Backrefs implements a subset of the Format Specification Mini-Language (<code>format_spec</code>) that allows for these features. As regular expression replacements are only working with string replacements (or byte strings), only string features are available with the <code>format_spec</code>, and only a subset of those are particularly useful.</p> <pre><code>replacement_field ::=  \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\"\nfield_name        ::=  arg_name (\".\" attribute_name | \"[\" element_index \"]\")*\narg_name          ::=  [identifier | integer]\nattribute_name    ::=  identifier\nelement_index     ::=  integer | index_string\nindex_string      ::=  &lt;any source character except \"]\"&gt; +\nconversion        ::=  \"r\" | \"s\" | \"a\"\nformat_spec       ::=  &lt;described in the next section&gt;\n</code></pre> <pre><code>format_spec ::=  [[fill]align][0][width][type]\nfill        ::=  &lt;any character&gt;\nalign       ::=  \"&lt;\" | \"&gt;\" | \"^\"\nwidth       ::=  integer\ntype        ::=  \"s\"\n</code></pre> </li> <li> <p>Lastly, our implementation of the Format Specification Mini-Language (<code>format_spec</code>) allows format     strings to work for byte strings as well as Unicode strings. This is something that Regex does not allow without     Backrefs.</p> <pre><code>&gt;&gt;&gt; bre.subf(br'(test)', br'\\C{0:|^8}\\E', b'test')\nb'||TEST||'\n</code></pre> <p>Conversion Syntax and Bytes</p> <p>In almost all instances, using conversion types (<code>{!s}</code>, etc.) won't make sense in a regular expression replace as the objects will already be strings in the needed format, but if you were to use a conversion using byte strings, when converting from <code>bytes</code> to <code>str</code>, ASCII will be the assumed encoding, and the object or Unicode string would be encoded using the <code>backslashreplace</code> option as well.</p> </li> </ol>"},{"location":"usage/#advanced-usage","title":"Advanced Usage","text":"<p>As noted, Backrefs wraps the regular expression object on compile with its own object. This is so it can provide the replace features seamlessly without the user having to do anything extra. But if you only wanted the search features, the <code>compile_search</code> method can be used to compile the pattern and directly return the regular expression object with no wrapper:</p> <pre><code>&gt;&gt;&gt; bre.compile_search(r'(\\p{ascii}+)')\nre.compile('([\\x00-\\x7f]+)')\n</code></pre> <p>Conversely, we could only use the replace features by compiling the pattern normally and giving it to the Backrefs API to create a replace object:</p> <pre><code>&gt;&gt;&gt; pattern = re.compile(r'(\\w+)')\n&gt;&gt;&gt; replace = bre.compile_replace(pattern, r'\\C\\1\\E')\n&gt;&gt;&gt; pattern.sub(replace, 'text')\n'TEXT'\n</code></pre> <p>You can also compile a replacement object directly from a <code>backrefs</code> object:</p> <pre><code>&gt;&gt;&gt; pattern = bre.compile(r'(\\w+)')\n&gt;&gt;&gt; replace = pattern.compile(r'\\C\\1\\E')\n&gt;&gt;&gt; pattern.sub(replace, 'text')\n'TEXT'\n</code></pre> <p>To pre-compile a format replace template, you can use the Backrefs' <code>compile_replace</code> method with the <code>FORMAT</code> flag.</p> <pre><code>&gt;&gt;&gt; pattern = bre.compile_search(r\"(\\w+) (\\w+)\")\n&gt;&gt;&gt; replace = bre.compile_replace(pattern, r\"{0} =&gt; {2} {1}\", bre.FORMAT)\n&gt;&gt;&gt; m = pattern.match(\"foo bar\")\n&gt;&gt;&gt; replace(m)\n'foo bar =&gt; bar foo'\n</code></pre> <p>Pre-compiled pattern objects can also create a compiled format replace object using the <code>FORMAT</code> flag.</p> <pre><code>&gt;&gt;&gt; pattern = bre.compile(r\"(?P&lt;word1&gt;\\w+) (?P&lt;word2&gt;\\w+)\")\n&gt;&gt;&gt; replace = pattern.compile(r\"\\c{word2} \\c{word1}\", bre.FORMAT)\n&gt;&gt;&gt; pattern.subf(replace, \"foo bar\")\n'Bar Foo'\n</code></pre>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#55","title":"5.5","text":"<ul> <li>NEW: <code>\\e</code> and <code>\\h</code> have both been deprecated in 6.0. Please migrate to using <code>\\x1b</code> and <code>\\p{Horiz_Space}</code> in     their respective place.</li> <li>FIX: Fix flag issue with <code>sub</code> functions.</li> </ul>"},{"location":"about/changelog/#54","title":"5.4","text":"<ul> <li>NEW: Officially support Python 3.11.</li> <li>NEW: Add to Bre compatible custom Unicode properties <code>\\p{Vert_Space}</code> and <code>\\p{Horiz_Space}</code> that match Regex's     new custom properties. This helps to expose vertical space shorthand that was not previously present.</li> </ul>"},{"location":"about/changelog/#53","title":"5.3","text":"<ul> <li>NEW: Drop Python 3.6 support.</li> <li>NEW: Update build backend to use Hatch.</li> </ul>"},{"location":"about/changelog/#52","title":"5.2","text":"<ul> <li>NEW: Add type annotations.</li> <li>FIX: Re format replacement captures behave more like Regex in that you can technically index into the captures     of a given group in Re, but in Re there is only ever one or zero captures. Documentation was never really explicit     on what one should expect if indexing a group in Re occurred. The documentation seemed to vaguely insinuate that it     would behave like a Regex capture list, just with one or zero values in the list. In reality, the value was a simple     string or <code>None</code>. This caused a bug in some cases where you'd have <code>None</code> inserted for a group if a group was     optional, but referenced in the replacement template. Now the implementation matches the description in the     documentation with the documentation now being more explicit about behavior.</li> <li>FIX: Match Re and Regex handling when doing a non-format replacement that references a group that is present in     the search pattern but has no actual captures. Such a case should not fail, but simply return an empty string for     the group.</li> <li>FIX: Format replacements that that have groups with no captures will yield an empty string as the only capture     as long as the user does not try to index into any captures as there are no actual captures. This behavior was a bug     in Regex that we duplicated and should now be fixed in the latest Regex (mrabarnett/mrab-regex#439) as well as in     Backrefs.</li> </ul>"},{"location":"about/changelog/#51","title":"5.1","text":"<ul> <li>NEW: Add support for Python 3.10.</li> </ul>"},{"location":"about/changelog/#501","title":"5.0.1","text":"<ul> <li>FIX: Fix wheel names.</li> </ul>"},{"location":"about/changelog/#50","title":"5.0","text":"<ul> <li>NEW: Significant improvements to Unicode handling. A lot of testing was implemented to catch existing bugs and     to improve result.</li> <li>NEW: POSIX style properties now handle all existing Unicode properties.</li> <li>NEW: POSIX properties now follow the Unicode specification for POSIX compatibility.     Read the documentation to learn more.</li> <li>NEW: Unicode properties are now sensitive to the <code>ASCII</code> flag and will properly restrict the range of properties     to the ASCII range even in Unicode strings.</li> <li>NEW: Removed the old deprecated search references: <code>\\l</code>, <code>\\L</code>, <code>\\c</code>, and <code>\\C</code>. These are available in various     other forms: <code>[[:lower:]]</code>, <code>\\p{lower}</code>, etc.</li> <li>NEW: To reduce conflicts of naming, Binary properties are evaluated before Block properties when using short     names. Block has conflicts with some other properties of various types, using short names for blocks is discouraged.</li> <li>FIX: Numerous fixes to existing Unicode properties: missing values, incorrect values, etc.</li> </ul>"},{"location":"about/changelog/#46","title":"4.6","text":"<ul> <li>NEW: Provide wheels for all officially supported versions of Python.</li> </ul>"},{"location":"about/changelog/#45","title":"4.5","text":"<ul> <li>NEW: Added new back reference <code>\\h</code> to Re. To get similar functionality with Regex, users must update to the     latest Regex release.</li> </ul>"},{"location":"about/changelog/#44","title":"4.4","text":"<ul> <li>NEW: Added the following binary properties for Unicode 13.0 support (Python 3.9): <code>emoji</code>, <code>emojicomponent</code>,     <code>emojimodifier</code>, <code>emojimodifierbase</code>, and <code>emojipresentation</code>. Associated aliases are also included: <code>ecomp</code>,     <code>emod</code>, <code>ebase</code>, and <code>epres</code>.</li> </ul>"},{"location":"about/changelog/#43","title":"4.3","text":"<ul> <li>NEW: Install Regex library along Backrefs via <code>pip install backrefs[extras]</code>.</li> <li>NEW: Remove <code>version</code> and <code>__version__</code> and remove associated deprecation code.</li> </ul>"},{"location":"about/changelog/#421","title":"4.2.1","text":"<ul> <li>FIX: Fix Python 3.8 installation issue due to Unicode bundle having an incorrect encoding in some files.</li> </ul>"},{"location":"about/changelog/#42","title":"4.2","text":"<ul> <li>NEW: Deprecate the search references <code>\\l</code>, <code>\\L</code>, <code>\\c</code>, and <code>\\C</code>. The POSIX alternatives (which these were     shortcuts for) should be used instead: <code>[[:lower:]]</code>, <code>[[:^lower:]]</code>, <code>[:upper:]]</code>, and <code>[[:^upper:]]</code> respectively.</li> <li>NEW: Formally drop support for Python 3.4.</li> </ul>"},{"location":"about/changelog/#411","title":"4.1.1","text":"<ul> <li>FIX: Later pre-release versions of Python 3.8 will support Unicode 12.1.0.</li> </ul>"},{"location":"about/changelog/#41","title":"4.1","text":"<ul> <li>NEW: Add official support for Python 3.8.</li> <li>NEW: Vendor the <code>Pep562</code> library instead of requiring as a dependency.</li> <li>NEW: Input parameters accept <code>*args</code> and <code>**kwargs</code> instead of specify every parameter in order to allow     Backrefs to work even when the Re or Regex API changes. Change was made to support new Regex <code>timeout</code> parameter.</li> </ul>"},{"location":"about/changelog/#402","title":"4.0.2","text":"<ul> <li>FIX: Fix compatibility issues with latest Regex versions.</li> </ul>"},{"location":"about/changelog/#401","title":"4.0.1","text":"<ul> <li>FIX: Ensure that when generating the Unicode property tables, that the property files are read in with <code>UTF-8</code>     encoding.</li> </ul>"},{"location":"about/changelog/#40","title":"4.0","text":"<ul> <li>NEW: Drop support for new features in Python 2. Python 2 support is limited to the 3.X.X series and will only     receive bug fixes up to 2020. All new features moving forward will be on the 4.X.X series and will be for Python 3+     only.</li> </ul>"},{"location":"about/changelog/#36","title":"3.6","text":"<ul> <li>NEW: Make version available via the new, and more standard, <code>__version__</code> attribute and add the     <code>__version_info__</code> attribute as well. Deprecate the old <code>version</code> and <code>version_info</code> attribute for future removal.</li> </ul>"},{"location":"about/changelog/#352","title":"3.5.2","text":"<ul> <li>FIX: Include zip for Unicode 11 (Python 3.7) to make installation more reliable.</li> </ul>"},{"location":"about/changelog/#351","title":"3.5.1","text":"<ul> <li>FIX: POSIX character classes should not be part of a range.</li> <li>FIX: Replace string casing logic properly follows other implementations like Boost etc. <code>\\L</code>, <code>\\C</code>, and <code>\\E</code>     should all terminate <code>\\L</code>, and <code>\\C</code>. <code>\\l</code> and <code>\\c</code> will be ignored if followed by <code>\\C</code> or <code>\\L</code>.</li> </ul>"},{"location":"about/changelog/#35","title":"3.5","text":"<ul> <li>NEW: Use a more advanced format string implementation that implements all string features, included those found     in <code>format_spec</code>.</li> <li>FIX: Relax validation so not to exclude valid named Unicode values.</li> <li>FIX: Caching issues where byte string patterns were confused with Unicode patterns.</li> <li>FIX: More protection against using conflicting string type combinations with search and replace.</li> </ul>"},{"location":"about/changelog/#34","title":"3.4","text":"<ul> <li>NEW: Add support for generic line breaks (<code>\\R</code>) to Re.</li> <li>NEW: Add support for an overly simplified form of grapheme clusters (<code>\\X</code>) to Re. Roughly equivalent to     <code>(?&gt;\\PM\\pM*)</code>.</li> <li>NEW: Add support for <code>Vertical_Orientation</code> property for Unicode 10.0.0 on Python 3.7.</li> </ul>"},{"location":"about/changelog/#33","title":"3.3","text":"<ul> <li>NEW: Add support for <code>Indic_Positional_Category</code>\\<code>Indic_Matra_Category</code> and <code>Indic_Syllabic_Category</code>     properties.</li> </ul>"},{"location":"about/changelog/#321","title":"3.2.1","text":"<ul> <li>FIX: <code>Bidi_Paired_Bracket_type</code> property's <code>None</code> value should be equivalent to all characters that are not     <code>open</code> or <code>close</code> characters.</li> </ul>"},{"location":"about/changelog/#32","title":"3.2","text":"<ul> <li>NEW: Add support for <code>Script_Extensions</code> Unicode properties (Python 3 only as Python 2, Unicode 5.2.0 does not     define these). Can be accessed via <code>\\p{scripts_extensions: kana}</code> or <code>\\p{scx: kana}</code>.</li> <li>NEW: When defining scripts with just their name <code>\\p{Kana}</code>, use <code>Script_Extensions</code> instead of <code>Scripts</code>. To get     <code>Scripts</code> results, you must specify <code>\\p{scripts: kana}</code> or <code>\\p{sc: scripts}</code>.</li> <li>NEW: Add <code>Bidi_Paired_Bracket_Type</code> Unicode property (Python 3.4+ only).</li> <li>NEW: Add support for <code>IsBinary</code> for binary properties: <code>\\p{IsAlphabetic}</code> == <code>\\p{Alphabetic: Y}</code>.</li> <li>FIX: Tweaks/improvements to string iteration.</li> </ul>"},{"location":"about/changelog/#312","title":"3.1.2","text":"<ul> <li>FIX: Properly escape any problematic characters in Unicode tables.</li> </ul>"},{"location":"about/changelog/#311","title":"3.1.1","text":"<ul> <li>FIX: <code>bregex.compile</code> now supports additional keyword arguments for named lists like <code>bregex.compile_search</code>     does.</li> </ul>"},{"location":"about/changelog/#31","title":"3.1","text":"<ul> <li>NEW: Start and end word boundary back references are now specified with <code>\\m</code> and <code>\\M</code> like Regex does.  <code>\\&lt;</code> and     <code>\\&gt;</code> have been removed from Regex.</li> <li>FIX: Escaped <code>\\&lt;</code> and <code>\\&gt;</code> are no longer processed as Re is known to escape these in versions less than Python     3.7.</li> </ul>"},{"location":"about/changelog/#305","title":"3.0.5","text":"<ul> <li>FIX: Process non raw string equivalent escaped Unicode on Python 2.7.</li> <li>FIX: Compiled objects should return the pattern string, not the pattern object via the property <code>pattern</code>.</li> </ul>"},{"location":"about/changelog/#304","title":"3.0.4","text":"<ul> <li>FIX: Formally enable Python 3.7 support.</li> <li>FIX: Tweak to Unicode wide character handling.</li> </ul>"},{"location":"about/changelog/#303","title":"3.0.3","text":"<ul> <li>FIX: Compiled search and replace objects should be hashable.</li> <li>FIX: Handle cases where a new compiled pattern object is passed back through compile functions.</li> </ul>"},{"location":"about/changelog/#302","title":"3.0.2","text":"<ul> <li>FIX: Bregex purge was calling Re's purge instead of Regex's purge.</li> </ul>"},{"location":"about/changelog/#301","title":"3.0.1","text":"<ul> <li>FIX: Do not accidentally <code>\\.</code> as a group in replace strings (don't use <code>isdigit</code> string method).</li> <li>FIX: Group names can start with <code>_</code> in replace strings.</li> <li>FIX: Do not rely on Re for parsing string.</li> <li>FIX: Match behavior in <code>\\g&lt;group&gt;</code> parsing better.</li> <li>FIX: Raise some exceptions in a few places we weren't.</li> </ul>"},{"location":"about/changelog/#30","title":"3.0","text":"<ul> <li>NEW: Added new <code>compile</code> function that returns a pattern object that feels like Re's and Regex's pattern object.</li> <li>NEW: Add some caching of search and replace patterns.</li> <li>NEW: Completely refactored algorithm for search and replace pattern augmentation.</li> <li>NEW: Add support for <code>\\e</code> for escape character <code>\\x1b</code> in both Re and Regex.</li> <li>NEW: Add support for <code>\\R</code> for generic newlines in the Regex module (Regex only).</li> <li>NEW: Support Unicode property form <code>\\pP</code> and <code>\\PP</code>.</li> <li>NEW: Add support for properly handling per group, scoped verbose flags in the preprocess step (Regex).</li> <li>NEW: Handle <code>(?#comments)</code> properly in the preprocess step.</li> <li>NEW: Add support for <code>\\N</code> in byte strings (characters out of range won't be included).</li> <li>NEW: Add support for <code>\\p</code> and <code>\\P</code> in byte strings (characters out of range won't be included).</li> <li>NEW: Add support for <code>\\&lt;</code> and <code>\\&gt;</code> word boundary escapes.</li> <li>FIX: Missing block properties on narrow systems when the property starts beyond the narrow limit.</li> <li>FIX: Fix issue where an invalid general category could sometimes pass and return no characters.</li> <li>FIX: Fix <code>\\Q...\\E</code> behavior so it is applied first as a separate step. No longer avoids <code>\\Q...\\E</code> in things like     character groups or comments.</li> <li>FIX: Flag related parsing issues in Regex and Re Python 3.6+.</li> </ul>"},{"location":"about/changelog/#22","title":"2.2","text":"<ul> <li>NEW: Proper support for <code>\\N{Unicode Name}</code>.</li> <li>FIX: Incomplete escapes will not be passed through, but will instead throw an error. For instance <code>\\p</code> should     only be passed through if it is complete <code>\\p{category}</code>.  Python 3.7 will error on this if we pass it through, and     Python 3.6 will generate warnings.  We should just consistently fail on it for all Python versions.</li> </ul>"},{"location":"about/changelog/#21","title":"2.1","text":"<ul> <li>NEW: Handle Unicode and byte notation in Re replace templates.</li> <li>NEW: Rework algorithm to handle replace casing back references in Python 3.7 development builds in preparation     for Python 3.7 release.</li> <li>NEW: Add support for case back references when using the Regex module's <code>subf</code> and <code>subfn</code>.</li> <li>NEW: Add new convenience method <code>expandf</code> to Regex that can take a format string and apply format style replaces.</li> <li>NEW: Add <code>FORMAT</code> flag to <code>compile_replace</code> to apply format style replaces when applicable.</li> <li>NEW: Add the same support that Regex has in relation to format style replacements to Re.</li> <li>NEW: Compiled replacements are now immutable.</li> <li>NEW: Various logic checking proper types and values.</li> <li>FIX: Fix octal/group logic in Regex and Re.</li> <li>FIX: Fix issue dealing with trailing backslashes in replace templates.</li> </ul>"},{"location":"about/changelog/#20","title":"2.0","text":"<ul> <li>NEW: First attempt at bringing Python 3.7 support, fixing back reference logic, and adding new back reference.     Released and then removed due to very poor behavior.</li> </ul>"},{"location":"about/changelog/#102","title":"1.0.2","text":"<ul> <li>FIX: Issues related to downloading Unicode data and Unicode table generation. Include Unicode data in release.</li> </ul>"},{"location":"about/changelog/#101","title":"1.0.1","text":"<ul> <li>FIX: Fixes for Python 3.6.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<ul> <li>NEW: Initial release.</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":""},{"location":"about/contributing/#overview","title":"Overview","text":"<p>Contribution from the community is encouraged and can be done in a variety of ways:</p> <ul> <li>Bug reports.</li> <li>Reviewing code.</li> <li>Code patches via pull requests.</li> <li>Documentation improvements via pull requests.</li> <li>Become a sponsor.</li> </ul>"},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try to find the answer to your question     before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much info as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to     reproduce the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses     to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of.</p> <p>Continuous integration tests on are run on all pull requests and commits via Travis CI.  When making a pull request, the tests will automatically be run, and the request must pass to be accepted.  You can (and should) run these tests before pull requesting.  If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge.</p> <p>Feel free to use a virtual environment if you are concerned about installing any of the Python packages.</p>"},{"location":"about/contributing/#running-validation-tests","title":"Running Validation Tests","text":"<ol> <li> <p>Make sure that Tox is installed:</p> <pre><code>pip install tox\n</code></pre> </li> <li> <p>Run Tox:</p> <pre><code>tox\n</code></pre> <p>Tox should install necessary dependencies and run the tests.</p> </li> </ol>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation.  Help with documentation is always appreciated and can be done via pull requests.  There shouldn't be any need to run validation tests if only updating documentation.</p> <p>You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs, the Material theme, and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages.  The command for previewing the docs is <code>mkdocs serve</code> from the root directory. You can then view the documents at <code>localhost:8000</code>.</p>"},{"location":"about/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2015 - 2023 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/security/","title":"Security Vulnerabilities","text":"<p>Our policy for security related issues is to fix related issues within our power on the most recent major release.</p>"},{"location":"about/security/#versioning","title":"Versioning","text":"<p>Versioning follows PEP440: <code>major.minior.patch</code>.</p> Versions Description Major This reserved for releases that introduce breaking features. Minor This reserved for releases that introduce new functionality. Patch This is reserved for releases that only include bug fixes. <p>Example</p> <pre><code>8.0\n8.1\n8.1.3\n</code></pre>"},{"location":"about/security/#create-security-vulnerability-report","title":"Create Security Vulnerability Report","text":"<p>If you have found a security vulnerability, you can create a draft \"security advisory\" on the GitHub repository, instructions here. Such advisories are kept private as the issue is explored.</p>"},{"location":"about/security/#security-vulnerability-workflow","title":"Security Vulnerability Workflow","text":"<p>We will strive to acknowledge the report in about two business days.</p> <p>Reports will be kept private until the issue is properly understood.</p> <p>If the report is accepted we will notify Tidelift (who we've partnered with), request a CVE from GitHub, and work with the reporter to find a resolution. Work will be done privately, and the final commit will not mention the security issue.</p> <p>The fix, announcement, and release will be negotiated with the reporter.</p> <p>Afterwards, a release will be made and the vulnerability will be made public as close to each other as possible.</p>"}]}