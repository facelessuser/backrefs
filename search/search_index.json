{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"User Guide \ue157 Overview \ue157 Backrefs is a wrapper around Python's built-in Re and the 3 rd party Regex library. Backrefs adds various additional back references (and a couple other features) that are known to some regular expression engines, but not to Python's Re and/or Regex. The supported back references actually vary depending on the regular expression engine being used as the engine may already have support for some, or things that prevent implementation of a feature. It is important to note that Backrefs doesn't alter the regular expression engine that it wraps around, it is essentially a string processor that looks for certain symbols in a regular expression search or replace string, and alters the pattern before sending it to the regular expression engine. For instance, if we used \\m in our regular expression, it would be transformed into \\b(?=\\w) . >>> bre . compile ( r 'test \\m' ) . pattern re.compile('test \\\\b(?=\\\\w)') Or if we used a Unicode property, it would be transformed into a character group: >>> bre . compile ( r 'test \\p {Cs} ' ) . pattern re.compile('test [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]') Replace templates are a little different than searches and require a bit more control to accomplish some of the replace features. Backrefs, like with searches, processes the string before passing it through the regular expression engine. Once Backrefs has parsed and altered the string as needed, it is then passed the regular expression engine to extract string literals and the group mapping (search groups to replace group placeholders). Backrefs will then return a replace object that should be used to apply the replace. The object will handle applying casing (upper or lower) to the returned captured groups, and assemble the desired string output. For these reasons, Backrefs requires you to compile your replaces and use the returned replace object if you want to take advantage of replace features. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> text = pattern . sub ( replace , 'sometext' ) 'SOMETEXT' Using Backrefs \ue157 Depending on which regular expression engine you are using (Re or Regex), you can import the appropriate module. from backrefs import bre from backrefs import bregex Backrefs can be applied to search patterns and/or replace patterns. You can control whether you want to use search augmentation, replace augmentation, or both. Search Patterns \ue157 To augment the search pattern of Re or Regex to utilize search back references, you can use Backrefs to compile the search. This will apply a preprocessor to the pattern and replace the back references (or other special syntax) with the appropriate content to construct a valid regular expression for Re or Regex. It will then return a valid compiled pattern for the respective regular expression engine. Since the return is a valid compiled pattern, you can use it as expected. >>> pattern = bre . compile_search ( r '\\p {Letter} +' , bre . UNICODE ) >>> pattern . match ( 'whatever' ) is not None True Replace Templates \ue157 Backrefs also provides special back references for replace templates as well. In order to utilize these back references, the template string must be run through a compiler as well. The replace compiler will run a preprocessor on the replace template that will strip out the back references and augment the template accordingly creating a valid replace template. Then it will return a replace object that can be used in place of your replace string. When used as your replace, the object will properly apply all the replace back references to your returned string and insert matched groups into the template. These replace objects can be passed into sub , subn etc. Search templates must be run through the compiler with an associated compiled search pattern so that it can properly map to the groups in your search pattern. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> text = pattern . sub ( replace , 'sometext' ) 'SOMETEXT' Since compiled replaces are not template strings, but functions, you wont be able to apply compiled replaces via m . expand ( replace ) . Instead, you can use the compiled replace directly. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> m = pattern . match ( 'sometext' ) >>> replace ( m ) 'SOMETEXT' If you have a one time expand, and don't feel like pre-compiling, you can use Backrefs expand method (it can also take pre-compiled patterns as well). >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> m = pattern . match ( 'sometext' ) >>> bre . expand ( m , r '\\C\\1\\E' ) 'SOMETEXT' Search & Replace Together \ue157 If you plan on using both the search and replace features, using compile_search and compile_replace can be a little awkward. If you wish to use something a bit more familiar, you can use the compile function to create a pattern object that mimics Re and Regex's pattern object. Once created, it will work very similar to how Re and Regex pattern objects work. It will also auto compile replace patterns for you: >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) 'SOMETEXT' If needed, you can use the object's compile function to pre-compile the replace patterns: >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> replace = pattern . compile ( r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'sometext' ) 'SOMETEXT' If you want to disable the patterns use of replace back references, you can disable the pre-compile of replace templates: >>> pattern = bre . compile ( r '(\\p {Letter} +)' , auto_compile = False ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) '\\\\Csometext\\\\E' Other Functions \ue157 Backrefs exposes most of the usual functions which Backrefs is wrapped around. For instance, Backrefs wraps around purge so that it can purge its cache along with the regular expression engine's cache. Backrefs also wraps around the global matching functions. So if you have a one time finditer , match , sub , search , or other operation, Backrefs provides wrappers for these methods too. The wrappers will compile the search and replace patterns for you on the fly, but they will also accept and pass pre-compiled patterns through as well. They should take all the flags and options your chosen regular expression engine normally accepts with the same names and positions. >>> bre . sub ( r '(\\p {Letter} +)' , r '\\C\\1\\E' , 'sometext' ) SOMETEXT In general, all options and flags for any of the compile, search, or replace wrappers should be the same as your actual regular expression engine. They are mirrored in the bre and bregex library to save you from having to import the the original re and regex respectively, but you could just as easily use the original flags if desired. In order to escape patterns formulated for Backrefs, you can simply use your regular expressions built-in escape method or the one mirrored in Backrefs; they are the same. >>> pattern = bre . compile_search ( bre . escape ( r '(\\p {Letter} +)' )) >>> bre . sub ( pattern , 'found it!' , '( \\\\ p {Letter} +)' ) 'found it!' Format Replacements \ue157 The Regex library has a feature where you can use format strings to implement replacements. This is useful for Regex as it provides a way to access different captures when multiple are captured by a single group. Most likely it was born from the need to provide an easy way to access multiple captures as Regex stores all captures while Re stores only the last. >>> regex . subf ( r \"(\\w+) (\\w+)\" , \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> regex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' >>> regex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Backrefs implements format string replacements in a way that is similar to Regex's that works for both Re and Regex. While it is similar to Regex's implementation, there are some differences. Though you can use normal strings with Backrefs' format templates, it is recommended to use raw strings for format replacements as back slashes are handled special to implement lower casing and upper casing via the replace back references. In Backrefs a template would look like r '\\L{1}{2}\\E' , and if you used a normal string it would look like ' \\\\ L{1}{2} \\\\ E' . Because Backrefs more or less requires raw strings for sane replace template creation, you can also use normal string and Unicode escapes in the format replace templates, so it should feel like a normal string. >>> bregex . subf ( r '(test)' , r '{0:\\n^8}' , 'test' ) '\\n\\ntest\\n\\n' >>> bregex . subf ( r '(test)' , r '\\C{0:\\u007c^8}\\E' , 'test' ) '||TEST||' Normally format strings don't allow you to index with negative integers as they are recognized as strings, but like Regex's format implementation, Backrefs allows you to use negative numbers ( -1 ), hex ( 0x01 ), octal ( 0o001 ), or even binary ( 0b1 ). While it may not be practical to use some of the latter forms, they are available to have feature parity with Regex's implementation. >>> bregex . subf ( r '(test)' , r ' {0[-1]} ' , 'test' ) 'test' Backrefs implements a subset of the Format Specification Mini-Language that allows for a few more additional features that Regex doesn't ( format_spec ). As regular expression replace is only dealing with strings (or byte strings), only string features are available with the format_spec . replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= <described in the next section> format_spec ::= [[fill]align][0][width][type] fill ::= <any character> align ::= \"<\" | \">\" | \"^\" width ::= integer type ::= \"s\" Note that in situations such as {:030} , where a width has a leading zero and no alignment specified, this would normally trigger the integer alignment = , but since integer features are not implemented, this would fail. Backrefs allows format strings to work for byte strings as well. In almost all instances, using conversion types won't make sense in a regular expression replace as the objects will already be strings in the needed format, but if you were to use a conversion, ASCII would be assumed, and the object or Unicode string would be encoded with backslashreplace . When using Backrefs' format replace, it should feel similar to Regex's format replace, except you will use raw strings: >>> bregex . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> bregex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' If using bregex , you can even index into groups that have multiple captures. >>> bregex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Formats also work for Re as well. >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' >>> bre . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \"\\c {word2} \\c {word1} \" , \"foo bar\" ) 'Bar Foo' You can also use {} {} which is the same as {0} {1} . >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {} => \\C {} {} \\E\" , \"foo bar\" ) 'foo bar => FOO BAR' To pre-compile a format replace template, you can use the Backrefs' compile_replace method with the FORMAT flag. >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> replace = bre . compile_replace ( pattern , r \" {0} => {2} {1} \" , bre . FORMAT ) >>> m = pattern . match ( \"foo bar\" ) >>> replace ( m ) 'foo bar => bar foo' Or you can use Backrefs' pattern objects. >>> pattern = bre . compile ( r \"(\\w+) (\\w+)\" ) >>> pattern . subf ( r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' Pre-compiled pattern objects can also create a compiled format replace object. >>> pattern = bre . compile ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" ) >>> replace = pattern . compile ( r \"\\c {word2} \\c {word1} \" , bre . FORMAT ) >>> pattern . subf ( replace , \"foo bar\" ) 'Bar Foo' Backrefs also provides an expand variant for format templates called expandf . >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> m = pattern . match ( 'foo bar' ) >>> bre . expandf ( m , r \" {0} => {2} {1} \" ) 'foo bar => bar foo' Search Back References \ue157 Each supported regular expression engine's supported search features vary, so features are broken up to show what is specifically added for Re and for Regex. Re \ue157 LOCALE and Character Properties Backrefs does not consider LOCALE when inserting POSIX or Unicode properties. In byte strings, Unicode properties will be truncated to the ASCII range of \\xff . POSIX properties will use either Unicode categories or POSIX categories depending on whether the UNICODE flag is set. If the LOCALE flag is set, it is considered not Unicode. Keep in mind that Backrefs doesn't stop LOCALE from being applied, only that Backrefs inserts its categories as either Unicode or ASCII only. Back References Description \\e Escape character \\x1b . \\c Deprecated : Shortcut for the uppercase POSIX character class [[:upper:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\l Deprecated : Shortcut for the lowercase POSIX character class [[:lower:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\C Deprecated : Shortcut for the inverse uppercase POSIX character class [[:^upper:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\L Deprecated : Shortcut for the inverse lowercase POSIX character class [[:^lower:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\p{UnicodeProperty} Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\pX Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\pL would be equivalent to \\p{L} or \\p{Letter} . \\P{UnicodeProperty} Inverse Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\PX Inverse Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\PL would be equivalent to \\P{L} or \\P{Letter} . [[:alnum:]] Though not really a back reference, support for POSIX style character classes is available. See POSIX Style Properties for more info. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. \\m Start word boundary. Translates to \\b(?=\\w) . \\M End word boundary. Translates to \\b(?<=\\w) . \\R Generic line breaks. This will use the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85\\u2028\\u2029]) which is roughly equivalent the to atomic group form that other engines use: (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) . When applied to byte strings, the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85]) will be used. \\X Grapheme clusters. This will use the pattern (?:\\PM\\pM*(?!\\pM)) which is roughly equivalent to the atomic group form that other engines use: (?>\\PM\\pM*) . This does not implement full, proper grapheme clusters like the 3 rd party Regex module does as this would require changes to the Re core engine. Instead it provides a simplified solution that has been seen in regular expression engines in the past. Deprecated 4.2.0 \\l , \\L , \\c , and \\C search back references have been deprecated in 4.2.0 and will be removed at some future time. It is recommended to use [[:lower:]] , [[:^lower:]] , [[:upper:]] , and [[:^upper:]] respectively. Regex \ue157 Note Regex already natively supports \\p{...} , \\P{...} , \\pX , \\PX , \\N{...} , \\X , \\m , and \\M so Backrefs does not attempt to add this to search patterns. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\R Generic line breaks. When searching a Unicode string, this will use the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) , and when applied to byte strings, the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85]) will be used. Replace Back References \ue157 The replace back references below apply to both Re and Regex and are essentially non-specific to the regular expression engine being used. Casing is applied to both the literal text and the replacement groups within the replace template. In most cases you'd only need to wrap the groups, but it may be useful to apply casing to the literal portions if you are dynamically assembling replacement patterns. LOCALE and Casing LOCALE is not considered when applying character casing. Unicode casing is applied in Unicode strings and ASCII casing is applied to byte strings. Back References Description \\c Uppercase the next character. \\l Lowercase the next character. \\C...\\E Apply uppercase to all characters until either the end of the string, the end marker \\E is found, or another \\C or \\L is encountered. \\L...\\E Apply lowercase to all characters until either the end of the string, the end marker \\E is found, or another \\L or \\C is encountered. \\U Wide Unicode character \\U00000057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\u Narrow Unicode character \\u0057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\x Byte character \\x57 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. Tip Complex configurations of casing should work fine. \\L\\cTEST\\E \u2192 Test \\c\\LTEST\\E \u2192 test \\L\\cTEST \\cTEST\\E \u2192 Test Test Unicode Properties \ue157 A number of various Unicode properties are supported in Backrefs, but only for Re as Regex already has its own implementation of Unicode properties. Some properties may not be available on certain Python versions due to the included Unicode build. It is important to note that Backrefs handles Unicode properties by transforming them to character classes with all the associated characters: \\p{Cs} \u2192 [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff] . Because of this, Backrefs can create really large regular expressions that the underlying engine must walk through. In short, Re with Backrefs will never be as efficient or fast as using Regex's Unicode properties, but it is very useful when you need or want to use Re. Also, keep in mind that there are most likely some differences between Regex's Unicode Properties and Backrefs' Unicode properties. One notable difference is Regex does not currently implement script_extensions while Backrefs' does and uses them as the default when specifying them in the form \\p{IsScriptValue} or \\p{ScriptValue} just like Perl does. See Special Syntax Exceptions for more info. Supported Properties Aliases Age Bidi_Class bc Bidi_Paired_Bracket_Type (Python 3+) bpt Binary Block blk Canonical_Combining_Class ccc Decomposition_Type dt East_Asian_Width ea General_Category gc Grapheme_Cluster_Break gcb Hangul_Syllable_Type hst Indic_Positional_Category (Python 3.5+) inpc Indic_Matra_Category (Python == 3.4) inmc Indic_Syllabic_Category (Python 3+) insc Joining_Group jg Joining_Type jt Line_Break lb NFC_Quick_Check nfcqc NFD_Quick_Check nfdqc NFKC_Quick_Check nfkcqc NFKD_Quick_Check nfkdqc Numeric_Type nt Numeric_Value nv Script sc Script_Extensions (Python 3+) scx Sentence_Break sb Vertical_Orientation (Python 3.7+) vt Word_Break wb Note The Binary property is not actually a property, but a group of different properties with binary characteristics. The available binary properties may differ from Unicode version to Unicode version. Exhaustive documentation on all these properties and their values is not currently provided. In general, we'll cover the syntax rules, and special exceptions to those rules for specific properties. Though we will outline all the values for General Category, we will not outline all of the valid values for the other properties. You can look at Perl's Unicode property documentation to get an idea of what values are appropriate for a given property, but keep in mind, syntax may vary from Perl's syntax. Unicode properties are specific to search patterns and can be used to specify a request to match all the characters in a specific Unicode property. Unicode properties can be used in byte strings, but the patterns will be restricted to the range \\x00-\\xff . If you are using a narrow python build, your max Unicode value will be \\uffff . Unicode blocks above that limit will not be available. Also Unicode values above the limit will not be available in character classes either. If you are using a wide build, you should have access to all Unicode values. Syntax \ue157 Unicode properties can be specified with the format: \\p{property=value} , \\p{property:value} . You can also do inverse properties by using the ^ character ( \\p{^property=value} ) or by using a capital P ( \\P{property=value} . \\P{property:value} ). Unicode properties may only have one property specified between the curly braces. If you want to use multiple properties to capture a singe character, create a character class: [\\p{UnicodeProperty}\\p{OtherUnicodeProperty}] . When specifying a property, the property and value matching is case insensitive and characters like [ -_] will be stripped out. So the following are all equivalent: \\p{Uppercase_Letter} , \\p{Uppercase-letter} , \\p{UPPERCASELETTER} , \\p{upper case letter} . There are a number of binary properties. In general, binary properties are specified by stating the binary property and a boolean value. True values can be Yes , Y , True , or T . False values can be No , N , False , or F . For example, to specify characters that are \"alphabetic\", we can use \\p{Alphabetic: Y} . To specify characters that are not \"alphabetic\": \\p{Alphabetic: N} . Special Syntax Exceptions \ue157 General Category, Script, Blocks, and Binary all can be specified by their value alone: \\p{value} , but they will be evaluated in the following order to resolve name conflicts as some the same value that is used in Script may be used in Blocks etc. General Category Script (with Script Extensions on Python 3+) Blocks Binary Script and Binary properties can also be defined in the format IsValue . For instance, if we wanted to match characters in the Latin script, we could use the syntax \\p{IsLatin} , which would be the same as \\p{Latin} or \\p{scx: Latin} . For Binary properties, \\p{IsAlphabetic} is the same as \\p{Alphabetic: Y} or \\p{Alphabetic} . Block properties have a similar short form as Script and Binary properties. For Blocks you can use InValue to specify a block. If we wanted to match characters in the Basic_Latin block, we could use the syntax \\p{InBasic_Latin} . This would be the same as \\p{Block: Basic_Latin} or \\p{Basic_Latin} . Lastly, you can specify general category properties in the form \\pX where X is the single letter terse property form. In this form, you can only use the single character values. So you could specify Letter , whose terse form is L with \\pL , but cannot specify Cased_Letter which has a terse form of Lc . See the table below to see all the Unicode General Category values and their terse forms. Verbose Property Form Terse Property Form Other C Control Cc Format Cf Surrogate Cs Private_Use Co Unassigned Cn Letter L Cased_Letter L& or Lc Uppercase_Letter Lu Lowercase_Letter Ll Titlecase_Letter Lt Modifier_Letter Lm Other_Letter Lo Mark M Nonspacing_Mark Mc Spacing_Mark Me Enclosing_Mark Md Number N Decimal_Number Nd Letter_Number Nl Other_Number No Punctuation P Connector_Punctuation Pc Dash_Punctuation Pd Open_Punctuation Ps Close_Punctuation Pe Initial_Punctuation Pi Final_Punctuation Pf Other_Punctuation Po Symbol S Math_Symbol Sm Currency_Symbol Sc Modifier_Symbol Sk Other_Symbol So Separator Z Space_Separator Zs Line_Separator Zl Paragraph_Separator Z POSIX Style Properties \ue157 A number of POSIX property names are also available in the form [:posix:] . Inverse properties are also available in the form [:^posix:] . These properties must only be included in a character class: [[:upper:]a-z] . There are two definitions for a given POSIX property: ASCII and Unicode. The Unicode definitions leverage Unicode properties and are only used if the pattern is a Unicode string and the regular expression's UNICODE flag is set. In Python 3, the default is Unicode unless the ASCII flag is set (the LOCALE flag is the equivalent of not having UNICODE set). The Unicode variants of the POSIX properties are also available via the \\p{...} form. There are some name collisions with existing Unicode properties like punct which exists as both a name for a Unicode property and a slightly different POSIX property. To access the POSIX property, you should prefix the name with posix : \\p{PosixPunct} . It should be noted that you can use the posix prefix to access any of the POSIX properties, even if there is no name collision. The POSIX properties are treated as binary Unicode properties . [:posix:] \\p{Posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"User Guide"},{"location":"#user-guide","text":"","title":"User Guide"},{"location":"#overview","text":"Backrefs is a wrapper around Python's built-in Re and the 3 rd party Regex library. Backrefs adds various additional back references (and a couple other features) that are known to some regular expression engines, but not to Python's Re and/or Regex. The supported back references actually vary depending on the regular expression engine being used as the engine may already have support for some, or things that prevent implementation of a feature. It is important to note that Backrefs doesn't alter the regular expression engine that it wraps around, it is essentially a string processor that looks for certain symbols in a regular expression search or replace string, and alters the pattern before sending it to the regular expression engine. For instance, if we used \\m in our regular expression, it would be transformed into \\b(?=\\w) . >>> bre . compile ( r 'test \\m' ) . pattern re.compile('test \\\\b(?=\\\\w)') Or if we used a Unicode property, it would be transformed into a character group: >>> bre . compile ( r 'test \\p {Cs} ' ) . pattern re.compile('test [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff]') Replace templates are a little different than searches and require a bit more control to accomplish some of the replace features. Backrefs, like with searches, processes the string before passing it through the regular expression engine. Once Backrefs has parsed and altered the string as needed, it is then passed the regular expression engine to extract string literals and the group mapping (search groups to replace group placeholders). Backrefs will then return a replace object that should be used to apply the replace. The object will handle applying casing (upper or lower) to the returned captured groups, and assemble the desired string output. For these reasons, Backrefs requires you to compile your replaces and use the returned replace object if you want to take advantage of replace features. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> text = pattern . sub ( replace , 'sometext' ) 'SOMETEXT'","title":"Overview"},{"location":"#using-backrefs","text":"Depending on which regular expression engine you are using (Re or Regex), you can import the appropriate module. from backrefs import bre from backrefs import bregex Backrefs can be applied to search patterns and/or replace patterns. You can control whether you want to use search augmentation, replace augmentation, or both.","title":"Using Backrefs"},{"location":"#search-patterns","text":"To augment the search pattern of Re or Regex to utilize search back references, you can use Backrefs to compile the search. This will apply a preprocessor to the pattern and replace the back references (or other special syntax) with the appropriate content to construct a valid regular expression for Re or Regex. It will then return a valid compiled pattern for the respective regular expression engine. Since the return is a valid compiled pattern, you can use it as expected. >>> pattern = bre . compile_search ( r '\\p {Letter} +' , bre . UNICODE ) >>> pattern . match ( 'whatever' ) is not None True","title":"Search Patterns"},{"location":"#replace-templates","text":"Backrefs also provides special back references for replace templates as well. In order to utilize these back references, the template string must be run through a compiler as well. The replace compiler will run a preprocessor on the replace template that will strip out the back references and augment the template accordingly creating a valid replace template. Then it will return a replace object that can be used in place of your replace string. When used as your replace, the object will properly apply all the replace back references to your returned string and insert matched groups into the template. These replace objects can be passed into sub , subn etc. Search templates must be run through the compiler with an associated compiled search pattern so that it can properly map to the groups in your search pattern. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> text = pattern . sub ( replace , 'sometext' ) 'SOMETEXT' Since compiled replaces are not template strings, but functions, you wont be able to apply compiled replaces via m . expand ( replace ) . Instead, you can use the compiled replace directly. >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> replace = bre . compile_replace ( pattern , r '\\C\\1\\E' ) >>> m = pattern . match ( 'sometext' ) >>> replace ( m ) 'SOMETEXT' If you have a one time expand, and don't feel like pre-compiling, you can use Backrefs expand method (it can also take pre-compiled patterns as well). >>> pattern = bre . compile_search ( r '(\\p {Letter} +)' ) >>> m = pattern . match ( 'sometext' ) >>> bre . expand ( m , r '\\C\\1\\E' ) 'SOMETEXT'","title":"Replace Templates"},{"location":"#search--replace-together","text":"If you plan on using both the search and replace features, using compile_search and compile_replace can be a little awkward. If you wish to use something a bit more familiar, you can use the compile function to create a pattern object that mimics Re and Regex's pattern object. Once created, it will work very similar to how Re and Regex pattern objects work. It will also auto compile replace patterns for you: >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) 'SOMETEXT' If needed, you can use the object's compile function to pre-compile the replace patterns: >>> pattern = bre . compile ( r '(\\p {Letter} +)' ) >>> replace = pattern . compile ( r '\\C\\1\\E' ) >>> pattern . sub ( replace , 'sometext' ) 'SOMETEXT' If you want to disable the patterns use of replace back references, you can disable the pre-compile of replace templates: >>> pattern = bre . compile ( r '(\\p {Letter} +)' , auto_compile = False ) >>> pattern . sub ( r '\\C\\1\\E' , 'sometext' ) '\\\\Csometext\\\\E'","title":"Search &amp; Replace Together"},{"location":"#other-functions","text":"Backrefs exposes most of the usual functions which Backrefs is wrapped around. For instance, Backrefs wraps around purge so that it can purge its cache along with the regular expression engine's cache. Backrefs also wraps around the global matching functions. So if you have a one time finditer , match , sub , search , or other operation, Backrefs provides wrappers for these methods too. The wrappers will compile the search and replace patterns for you on the fly, but they will also accept and pass pre-compiled patterns through as well. They should take all the flags and options your chosen regular expression engine normally accepts with the same names and positions. >>> bre . sub ( r '(\\p {Letter} +)' , r '\\C\\1\\E' , 'sometext' ) SOMETEXT In general, all options and flags for any of the compile, search, or replace wrappers should be the same as your actual regular expression engine. They are mirrored in the bre and bregex library to save you from having to import the the original re and regex respectively, but you could just as easily use the original flags if desired. In order to escape patterns formulated for Backrefs, you can simply use your regular expressions built-in escape method or the one mirrored in Backrefs; they are the same. >>> pattern = bre . compile_search ( bre . escape ( r '(\\p {Letter} +)' )) >>> bre . sub ( pattern , 'found it!' , '( \\\\ p {Letter} +)' ) 'found it!'","title":"Other Functions"},{"location":"#format-replacements","text":"The Regex library has a feature where you can use format strings to implement replacements. This is useful for Regex as it provides a way to access different captures when multiple are captured by a single group. Most likely it was born from the need to provide an easy way to access multiple captures as Regex stores all captures while Re stores only the last. >>> regex . subf ( r \"(\\w+) (\\w+)\" , \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> regex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' >>> regex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Backrefs implements format string replacements in a way that is similar to Regex's that works for both Re and Regex. While it is similar to Regex's implementation, there are some differences. Though you can use normal strings with Backrefs' format templates, it is recommended to use raw strings for format replacements as back slashes are handled special to implement lower casing and upper casing via the replace back references. In Backrefs a template would look like r '\\L{1}{2}\\E' , and if you used a normal string it would look like ' \\\\ L{1}{2} \\\\ E' . Because Backrefs more or less requires raw strings for sane replace template creation, you can also use normal string and Unicode escapes in the format replace templates, so it should feel like a normal string. >>> bregex . subf ( r '(test)' , r '{0:\\n^8}' , 'test' ) '\\n\\ntest\\n\\n' >>> bregex . subf ( r '(test)' , r '\\C{0:\\u007c^8}\\E' , 'test' ) '||TEST||' Normally format strings don't allow you to index with negative integers as they are recognized as strings, but like Regex's format implementation, Backrefs allows you to use negative numbers ( -1 ), hex ( 0x01 ), octal ( 0o001 ), or even binary ( 0b1 ). While it may not be practical to use some of the latter forms, they are available to have feature parity with Regex's implementation. >>> bregex . subf ( r '(test)' , r ' {0[-1]} ' , 'test' ) 'test' Backrefs implements a subset of the Format Specification Mini-Language that allows for a few more additional features that Regex doesn't ( format_spec ). As regular expression replace is only dealing with strings (or byte strings), only string features are available with the format_spec . replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= <described in the next section> format_spec ::= [[fill]align][0][width][type] fill ::= <any character> align ::= \"<\" | \">\" | \"^\" width ::= integer type ::= \"s\" Note that in situations such as {:030} , where a width has a leading zero and no alignment specified, this would normally trigger the integer alignment = , but since integer features are not implemented, this would fail. Backrefs allows format strings to work for byte strings as well. In almost all instances, using conversion types won't make sense in a regular expression replace as the objects will already be strings in the needed format, but if you were to use a conversion, ASCII would be assumed, and the object or Unicode string would be encoded with backslashreplace . When using Backrefs' format replace, it should feel similar to Regex's format replace, except you will use raw strings: >>> bregex . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => {2} {1} \" , \"foo bar\" ) 'foo bar => bar foo' >>> bregex . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \" {word2} {word1} \" , \"foo bar\" ) 'bar foo' If using bregex , you can even index into groups that have multiple captures. >>> bregex . subf ( r \"(\\w)+ (\\w+)\" , \" {0} => {2} {1[0]} \" , \"foo bar\" ) 'foo bar => bar f' Formats also work for Re as well. >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' >>> bre . subf ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" , r \"\\c {word2} \\c {word1} \" , \"foo bar\" ) 'Bar Foo' You can also use {} {} which is the same as {0} {1} . >>> bre . subf ( r \"(\\w+) (\\w+)\" , r \" {} => \\C {} {} \\E\" , \"foo bar\" ) 'foo bar => FOO BAR' To pre-compile a format replace template, you can use the Backrefs' compile_replace method with the FORMAT flag. >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> replace = bre . compile_replace ( pattern , r \" {0} => {2} {1} \" , bre . FORMAT ) >>> m = pattern . match ( \"foo bar\" ) >>> replace ( m ) 'foo bar => bar foo' Or you can use Backrefs' pattern objects. >>> pattern = bre . compile ( r \"(\\w+) (\\w+)\" ) >>> pattern . subf ( r \" {0} => \\C {2} {1} \\E\" , \"foo bar\" ) 'foo bar => BAR FOO' Pre-compiled pattern objects can also create a compiled format replace object. >>> pattern = bre . compile ( r \"(?P<word1>\\w+) (?P<word2>\\w+)\" ) >>> replace = pattern . compile ( r \"\\c {word2} \\c {word1} \" , bre . FORMAT ) >>> pattern . subf ( replace , \"foo bar\" ) 'Bar Foo' Backrefs also provides an expand variant for format templates called expandf . >>> pattern = bre . compile_search ( r \"(\\w+) (\\w+)\" ) >>> m = pattern . match ( 'foo bar' ) >>> bre . expandf ( m , r \" {0} => {2} {1} \" ) 'foo bar => bar foo'","title":"Format Replacements"},{"location":"#search-back-references","text":"Each supported regular expression engine's supported search features vary, so features are broken up to show what is specifically added for Re and for Regex.","title":"Search Back References"},{"location":"#re","text":"LOCALE and Character Properties Backrefs does not consider LOCALE when inserting POSIX or Unicode properties. In byte strings, Unicode properties will be truncated to the ASCII range of \\xff . POSIX properties will use either Unicode categories or POSIX categories depending on whether the UNICODE flag is set. If the LOCALE flag is set, it is considered not Unicode. Keep in mind that Backrefs doesn't stop LOCALE from being applied, only that Backrefs inserts its categories as either Unicode or ASCII only. Back References Description \\e Escape character \\x1b . \\c Deprecated : Shortcut for the uppercase POSIX character class [[:upper:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\l Deprecated : Shortcut for the lowercase POSIX character class [[:lower:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\C Deprecated : Shortcut for the inverse uppercase POSIX character class [[:^upper:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\L Deprecated : Shortcut for the inverse lowercase POSIX character class [[:^lower:]] . ASCII or Unicode when re Unicode flag is used. Can be used in character classes [] . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\p{UnicodeProperty} Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\pX Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\pL would be equivalent to \\p{L} or \\p{Letter} . \\P{UnicodeProperty} Inverse Unicode property character class. Can be used in character classes [] . See Unicode Properties for more info. \\PX Inverse Unicode property character class where X is the uppercase letter that represents the General Category property. For instance, \\PL would be equivalent to \\P{L} or \\P{Letter} . [[:alnum:]] Though not really a back reference, support for POSIX style character classes is available. See POSIX Style Properties for more info. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. \\m Start word boundary. Translates to \\b(?=\\w) . \\M End word boundary. Translates to \\b(?<=\\w) . \\R Generic line breaks. This will use the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85\\u2028\\u2029]) which is roughly equivalent the to atomic group form that other engines use: (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) . When applied to byte strings, the pattern (?:\\r\\n|(?!\\r\\n)[\\n\\v\\f\\r\\x85]) will be used. \\X Grapheme clusters. This will use the pattern (?:\\PM\\pM*(?!\\pM)) which is roughly equivalent to the atomic group form that other engines use: (?>\\PM\\pM*) . This does not implement full, proper grapheme clusters like the 3 rd party Regex module does as this would require changes to the Re core engine. Instead it provides a simplified solution that has been seen in regular expression engines in the past. Deprecated 4.2.0 \\l , \\L , \\c , and \\C search back references have been deprecated in 4.2.0 and will be removed at some future time. It is recommended to use [[:lower:]] , [[:^lower:]] , [[:upper:]] , and [[:^upper:]] respectively.","title":"Re"},{"location":"#regex","text":"Note Regex already natively supports \\p{...} , \\P{...} , \\pX , \\PX , \\N{...} , \\X , \\m , and \\M so Backrefs does not attempt to add this to search patterns. Back References Description \\e Escape character \\x1b . \\Q...\\E Quotes (escapes) text for regular expression. \\E signifies the end of the quoting. Affects any and all characters no matter where in the regular expression pattern it is placed. \\R Generic line breaks. When searching a Unicode string, this will use the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]) , and when applied to byte strings, the pattern (?>\\r\\n|[\\n\\v\\f\\r\\x85]) will be used.","title":"Regex"},{"location":"#replace-back-references","text":"The replace back references below apply to both Re and Regex and are essentially non-specific to the regular expression engine being used. Casing is applied to both the literal text and the replacement groups within the replace template. In most cases you'd only need to wrap the groups, but it may be useful to apply casing to the literal portions if you are dynamically assembling replacement patterns. LOCALE and Casing LOCALE is not considered when applying character casing. Unicode casing is applied in Unicode strings and ASCII casing is applied to byte strings. Back References Description \\c Uppercase the next character. \\l Lowercase the next character. \\C...\\E Apply uppercase to all characters until either the end of the string, the end marker \\E is found, or another \\C or \\L is encountered. \\L...\\E Apply lowercase to all characters until either the end of the string, the end marker \\E is found, or another \\L or \\C is encountered. \\U Wide Unicode character \\U00000057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\u Narrow Unicode character \\u0057 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\x Byte character \\x57 . Re doesn't translate this notation in raw strings ( r \"...\" ), and Regex doesn't in format templates in raw strings ( r \" {} {} \" ). This adds support for them. \\N{UnicodeName} Named characters are are normally ignored in Re, but Backrefs adds support for them. Tip Complex configurations of casing should work fine. \\L\\cTEST\\E \u2192 Test \\c\\LTEST\\E \u2192 test \\L\\cTEST \\cTEST\\E \u2192 Test Test","title":"Replace Back References"},{"location":"#unicode-properties","text":"A number of various Unicode properties are supported in Backrefs, but only for Re as Regex already has its own implementation of Unicode properties. Some properties may not be available on certain Python versions due to the included Unicode build. It is important to note that Backrefs handles Unicode properties by transforming them to character classes with all the associated characters: \\p{Cs} \u2192 [\\ud800\\udb7f-\\udb80\\udbff-\\udc00\\udfff] . Because of this, Backrefs can create really large regular expressions that the underlying engine must walk through. In short, Re with Backrefs will never be as efficient or fast as using Regex's Unicode properties, but it is very useful when you need or want to use Re. Also, keep in mind that there are most likely some differences between Regex's Unicode Properties and Backrefs' Unicode properties. One notable difference is Regex does not currently implement script_extensions while Backrefs' does and uses them as the default when specifying them in the form \\p{IsScriptValue} or \\p{ScriptValue} just like Perl does. See Special Syntax Exceptions for more info. Supported Properties Aliases Age Bidi_Class bc Bidi_Paired_Bracket_Type (Python 3+) bpt Binary Block blk Canonical_Combining_Class ccc Decomposition_Type dt East_Asian_Width ea General_Category gc Grapheme_Cluster_Break gcb Hangul_Syllable_Type hst Indic_Positional_Category (Python 3.5+) inpc Indic_Matra_Category (Python == 3.4) inmc Indic_Syllabic_Category (Python 3+) insc Joining_Group jg Joining_Type jt Line_Break lb NFC_Quick_Check nfcqc NFD_Quick_Check nfdqc NFKC_Quick_Check nfkcqc NFKD_Quick_Check nfkdqc Numeric_Type nt Numeric_Value nv Script sc Script_Extensions (Python 3+) scx Sentence_Break sb Vertical_Orientation (Python 3.7+) vt Word_Break wb Note The Binary property is not actually a property, but a group of different properties with binary characteristics. The available binary properties may differ from Unicode version to Unicode version. Exhaustive documentation on all these properties and their values is not currently provided. In general, we'll cover the syntax rules, and special exceptions to those rules for specific properties. Though we will outline all the values for General Category, we will not outline all of the valid values for the other properties. You can look at Perl's Unicode property documentation to get an idea of what values are appropriate for a given property, but keep in mind, syntax may vary from Perl's syntax. Unicode properties are specific to search patterns and can be used to specify a request to match all the characters in a specific Unicode property. Unicode properties can be used in byte strings, but the patterns will be restricted to the range \\x00-\\xff . If you are using a narrow python build, your max Unicode value will be \\uffff . Unicode blocks above that limit will not be available. Also Unicode values above the limit will not be available in character classes either. If you are using a wide build, you should have access to all Unicode values.","title":"Unicode Properties"},{"location":"#syntax","text":"Unicode properties can be specified with the format: \\p{property=value} , \\p{property:value} . You can also do inverse properties by using the ^ character ( \\p{^property=value} ) or by using a capital P ( \\P{property=value} . \\P{property:value} ). Unicode properties may only have one property specified between the curly braces. If you want to use multiple properties to capture a singe character, create a character class: [\\p{UnicodeProperty}\\p{OtherUnicodeProperty}] . When specifying a property, the property and value matching is case insensitive and characters like [ -_] will be stripped out. So the following are all equivalent: \\p{Uppercase_Letter} , \\p{Uppercase-letter} , \\p{UPPERCASELETTER} , \\p{upper case letter} . There are a number of binary properties. In general, binary properties are specified by stating the binary property and a boolean value. True values can be Yes , Y , True , or T . False values can be No , N , False , or F . For example, to specify characters that are \"alphabetic\", we can use \\p{Alphabetic: Y} . To specify characters that are not \"alphabetic\": \\p{Alphabetic: N} .","title":"Syntax"},{"location":"#special-syntax-exceptions","text":"General Category, Script, Blocks, and Binary all can be specified by their value alone: \\p{value} , but they will be evaluated in the following order to resolve name conflicts as some the same value that is used in Script may be used in Blocks etc. General Category Script (with Script Extensions on Python 3+) Blocks Binary Script and Binary properties can also be defined in the format IsValue . For instance, if we wanted to match characters in the Latin script, we could use the syntax \\p{IsLatin} , which would be the same as \\p{Latin} or \\p{scx: Latin} . For Binary properties, \\p{IsAlphabetic} is the same as \\p{Alphabetic: Y} or \\p{Alphabetic} . Block properties have a similar short form as Script and Binary properties. For Blocks you can use InValue to specify a block. If we wanted to match characters in the Basic_Latin block, we could use the syntax \\p{InBasic_Latin} . This would be the same as \\p{Block: Basic_Latin} or \\p{Basic_Latin} . Lastly, you can specify general category properties in the form \\pX where X is the single letter terse property form. In this form, you can only use the single character values. So you could specify Letter , whose terse form is L with \\pL , but cannot specify Cased_Letter which has a terse form of Lc . See the table below to see all the Unicode General Category values and their terse forms. Verbose Property Form Terse Property Form Other C Control Cc Format Cf Surrogate Cs Private_Use Co Unassigned Cn Letter L Cased_Letter L& or Lc Uppercase_Letter Lu Lowercase_Letter Ll Titlecase_Letter Lt Modifier_Letter Lm Other_Letter Lo Mark M Nonspacing_Mark Mc Spacing_Mark Me Enclosing_Mark Md Number N Decimal_Number Nd Letter_Number Nl Other_Number No Punctuation P Connector_Punctuation Pc Dash_Punctuation Pd Open_Punctuation Ps Close_Punctuation Pe Initial_Punctuation Pi Final_Punctuation Pf Other_Punctuation Po Symbol S Math_Symbol Sm Currency_Symbol Sc Modifier_Symbol Sk Other_Symbol So Separator Z Space_Separator Zs Line_Separator Zl Paragraph_Separator Z","title":"Special Syntax Exceptions"},{"location":"#posix-style-properties","text":"A number of POSIX property names are also available in the form [:posix:] . Inverse properties are also available in the form [:^posix:] . These properties must only be included in a character class: [[:upper:]a-z] . There are two definitions for a given POSIX property: ASCII and Unicode. The Unicode definitions leverage Unicode properties and are only used if the pattern is a Unicode string and the regular expression's UNICODE flag is set. In Python 3, the default is Unicode unless the ASCII flag is set (the LOCALE flag is the equivalent of not having UNICODE set). The Unicode variants of the POSIX properties are also available via the \\p{...} form. There are some name collisions with existing Unicode properties like punct which exists as both a name for a Unicode property and a slightly different POSIX property. To access the POSIX property, you should prefix the name with posix : \\p{PosixPunct} . It should be noted that you can use the posix prefix to access any of the POSIX properties, even if there is no name collision. The POSIX properties are treated as binary Unicode properties . [:posix:] \\p{Posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Style Properties"},{"location":"changelog/","text":"Changelog \ue157 4.2.1 \ue157 FIX : Fix Python 3.8 installation issue due to Unicode bundle having an incorrect encoding in some files. 4.2.0 \ue157 NEW : Deprecate the search references \\l , \\L , \\c , and \\C . The POSIX alternatives (which these were shortcuts for) should be used instead: [[:lower:]] , [[:^lower:]] , [:upper:]] , and [[:^upper:]] respectively. NEW : Formally drop support for Python 3.4. 4.1.1 \ue157 FIX : Later pre-release versions of Python 3.8 will support Unicode 12.1.0. 4.1.0 \ue157 NEW : Add official support for Python 3.8. NEW : Vendor the Pep562 library instead of requiring as a dependency. NEW : Input parameters accept *args and **kwargs instead of specify every parameter in order to allow Backrefs to work even when the Re or Regex API changes. Change was made to support new Regex timeout parameter. 4.0.2 \ue157 FIX : Fix compatibility issues with latest Regex versions. 4.0.1 \ue157 FIX : Ensure that when generating the Unicode property tables, that the property files are read in with UTF-8 encoding. 4.0.0 \ue157 NEW : Drop support for new features in Python 2. Python 2 support is limited to the 3.X.X series and will only receive bug fixes up to 2020. All new features moving forward will be on the 4.X.X series and will be for Python 3+ only. 3.6.0 \ue157 NEW : Make version available via the new, and more standard, __version__ attribute and add the __version_info__ attribute as well. Deprecate the old version and version_info attribute for future removal. 3.5.2 \ue157 FIX : Include zip for Unicode 11 (Python 3.7) to make installation more reliable. 3.5.1 \ue157 FIX : POSIX character classes should not be part of a range. FIX : Replace string casing logic properly follows other implementations like Boost etc. \\L , \\C , and \\E should all terminate \\L , and \\C . \\l and \\c will be ignored if followed by \\C or \\L . 3.5.0 \ue157 NEW : Use a more advanced format string implementation that implements all string features, included those found in format_spec . FIX : Relax validation so not to exclude valid named Unicode values. FIX : Caching issues where byte string patterns were confused with Unicode patterns. FIX : More protection against using conflicting string type combinations with search and replace. 3.4.0 \ue157 NEW : Add support for generic line breaks ( \\R ) to Re. NEW : Add support for an overly simplified form of grapheme clusters ( \\X ) to Re. Roughly equivalent to (?>\\PM\\pM*) . NEW : Add support for Vertical_Orientation property for Unicode 10.0.0 on Python 3.7. 3.3.0 \ue157 NEW : Add support for Indic_Positional_Category \\ Indic_Matra_Category and Indic_Syllabic_Category properties. 3.2.1 \ue157 FIX : Bidi_Paired_Bracket_type property's None value should be equivalent to all characters that are not open or close characters. 3.2.0 \ue157 NEW : Add support for Script_Extensions Unicode properties (Python 3 only as Python 2, Unicode 5.2.0 does not define these). Can be accessed via \\p{scripts_extensions: kana} or \\p{scx: kana} . NEW : When defining scripts with just their name \\p{Kana} , use Script_Extensions instead of Scripts . To get Scripts results, you must specify \\p{scripts: kana} or \\p{sc: scripts} . NEW : Add Bidi_Paired_Bracket_Type Unicode property (Python 3.4+ only). NEW : Add support for IsBinary for binary properties: \\p{IsAlphabetic} == \\p{Alphabetic: Y} . FIX : Tweaks/improvements to string iteration. 3.1.2 \ue157 FIX : Properly escape any problematic characters in Unicode tables. 3.1.1 \ue157 Feb 11, 2018 FIX : bregex.compile now supports additional keyword arguments for named lists like bregex.compile_search does. 3.1.0 \ue157 NEW : Start and end word boundary back references are now specified with \\m and \\M like Regex does. \\< and \\> have been removed from Regex. FIX : Escaped \\< and \\> are no longer processed as Re is known to escape these in versions less than Python 3.7. 3.0.5 \ue157 FIX : Process non raw string equivalent escaped Unicode on Python 2.7. FIX : Compiled objects should return the pattern string, not the pattern object via the property pattern . 3.0.4 \ue157 FIX : Formally enable Python 3.7 support. FIX : Tweak to Unicode wide character handling. 3.0.3 \ue157 FIX : Compiled search and replace objects should be hashable. FIX : Handle cases where a new compiled pattern object is passed back through compile functions. 3.0.2 \ue157 FIX : Bregex purge was calling Re's purge instead of Regex's purge. 3.0.1 \ue157 FIX : Do not accidentally \\. as a group in replace strings (don't use isdigit string method). FIX : Group names can start with _ in replace strings. FIX : Do not rely on Re for parsing string. FIX : Match behavior in \\g<group> parsing better. FIX : Raise some exceptions in a few places we weren't. 3.0.0 \ue157 NEW : Added new compile function that returns a pattern object that feels like Re's and Regex's pattern object. NEW : Add some caching of search and replace patterns. NEW : Completely refactored algorithm for search and replace pattern augmentation. NEW : Add support for \\e for escape character \\x1b in both Re and Regex. NEW : Add support for \\R for generic newlines in the Regex module (Regex only). NEW : Support Unicode property form \\pP and \\PP . NEW : Add support for properly handling per group, scoped verbose flags in the preprocess step (Regex). NEW : Handle (?#comments) properly in the preprocess step. NEW : Add support for \\N in byte strings (characters out of range won't be included). NEW : Add support for \\p and \\P in byte strings (characters out of range won't be included). NEW : Add support for \\< and \\> word boundary escapes. FIX : Missing block properties on narrow systems when the property starts beyond the narrow limit. FIX : Fix issue where an invalid general category could sometimes pass and return no characters. FIX : Fix \\Q...\\E behavior so it is applied first as a separate step. No longer avoids \\Q...\\E in things like character groups or comments. FIX : Flag related parsing issues in Regex and Re Python 3.6+. 2.2.0 \ue157 NEW : Proper support for \\N{Unicode Name} . FIX : Incomplete escapes will not be passed through, but will instead throw an error. For instance \\p should only be passed through if it is complete \\p{category} . Python 3.7 will error on this if we pass it through, and Python 3.6 will generate warnings. We should just consistently fail on it for all Python versions. 2.1.0 \ue157 NEW : Handle Unicode and byte notation in Re replace templates. NEW : Rework algorithm to handle replace casing back references in Python 3.7 development builds in preparation for Python 3.7 release. NEW : Add support for case back references when using the Regex module's subf and subfn . NEW : Add new convenience method expandf to Regex that can take a format string and apply format style replaces. NEW : Add FORMAT flag to compile_replace to apply format style replaces when applicable. NEW : Add the same support that Regex has in relation to format style replacements to Re. NEW : Compiled replacements are now immutable. NEW : Various logic checking proper types and values. FIX : Fix octal/group logic in Regex and Re. FIX : Fix issue dealing with trailing backslashes in replace templates. 2.0.0 \ue157 NEW : First attempt at bringing Python 3.7 support, fixing back reference logic, and adding new back reference. Released and then removed due to very poor behavior. 1.0.2 \ue157 FIX : Issues related to downloading Unicode data and Unicode table generation. Include Unicode data in release. 1.0.1 \ue157 FIX : Fixes for Python 3.6. 1.0.0 \ue157 NEW : Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#421","text":"FIX : Fix Python 3.8 installation issue due to Unicode bundle having an incorrect encoding in some files.","title":"4.2.1"},{"location":"changelog/#420","text":"NEW : Deprecate the search references \\l , \\L , \\c , and \\C . The POSIX alternatives (which these were shortcuts for) should be used instead: [[:lower:]] , [[:^lower:]] , [:upper:]] , and [[:^upper:]] respectively. NEW : Formally drop support for Python 3.4.","title":"4.2.0"},{"location":"changelog/#411","text":"FIX : Later pre-release versions of Python 3.8 will support Unicode 12.1.0.","title":"4.1.1"},{"location":"changelog/#410","text":"NEW : Add official support for Python 3.8. NEW : Vendor the Pep562 library instead of requiring as a dependency. NEW : Input parameters accept *args and **kwargs instead of specify every parameter in order to allow Backrefs to work even when the Re or Regex API changes. Change was made to support new Regex timeout parameter.","title":"4.1.0"},{"location":"changelog/#402","text":"FIX : Fix compatibility issues with latest Regex versions.","title":"4.0.2"},{"location":"changelog/#401","text":"FIX : Ensure that when generating the Unicode property tables, that the property files are read in with UTF-8 encoding.","title":"4.0.1"},{"location":"changelog/#400","text":"NEW : Drop support for new features in Python 2. Python 2 support is limited to the 3.X.X series and will only receive bug fixes up to 2020. All new features moving forward will be on the 4.X.X series and will be for Python 3+ only.","title":"4.0.0"},{"location":"changelog/#360","text":"NEW : Make version available via the new, and more standard, __version__ attribute and add the __version_info__ attribute as well. Deprecate the old version and version_info attribute for future removal.","title":"3.6.0"},{"location":"changelog/#352","text":"FIX : Include zip for Unicode 11 (Python 3.7) to make installation more reliable.","title":"3.5.2"},{"location":"changelog/#351","text":"FIX : POSIX character classes should not be part of a range. FIX : Replace string casing logic properly follows other implementations like Boost etc. \\L , \\C , and \\E should all terminate \\L , and \\C . \\l and \\c will be ignored if followed by \\C or \\L .","title":"3.5.1"},{"location":"changelog/#350","text":"NEW : Use a more advanced format string implementation that implements all string features, included those found in format_spec . FIX : Relax validation so not to exclude valid named Unicode values. FIX : Caching issues where byte string patterns were confused with Unicode patterns. FIX : More protection against using conflicting string type combinations with search and replace.","title":"3.5.0"},{"location":"changelog/#340","text":"NEW : Add support for generic line breaks ( \\R ) to Re. NEW : Add support for an overly simplified form of grapheme clusters ( \\X ) to Re. Roughly equivalent to (?>\\PM\\pM*) . NEW : Add support for Vertical_Orientation property for Unicode 10.0.0 on Python 3.7.","title":"3.4.0"},{"location":"changelog/#330","text":"NEW : Add support for Indic_Positional_Category \\ Indic_Matra_Category and Indic_Syllabic_Category properties.","title":"3.3.0"},{"location":"changelog/#321","text":"FIX : Bidi_Paired_Bracket_type property's None value should be equivalent to all characters that are not open or close characters.","title":"3.2.1"},{"location":"changelog/#320","text":"NEW : Add support for Script_Extensions Unicode properties (Python 3 only as Python 2, Unicode 5.2.0 does not define these). Can be accessed via \\p{scripts_extensions: kana} or \\p{scx: kana} . NEW : When defining scripts with just their name \\p{Kana} , use Script_Extensions instead of Scripts . To get Scripts results, you must specify \\p{scripts: kana} or \\p{sc: scripts} . NEW : Add Bidi_Paired_Bracket_Type Unicode property (Python 3.4+ only). NEW : Add support for IsBinary for binary properties: \\p{IsAlphabetic} == \\p{Alphabetic: Y} . FIX : Tweaks/improvements to string iteration.","title":"3.2.0"},{"location":"changelog/#312","text":"FIX : Properly escape any problematic characters in Unicode tables.","title":"3.1.2"},{"location":"changelog/#311","text":"Feb 11, 2018 FIX : bregex.compile now supports additional keyword arguments for named lists like bregex.compile_search does.","title":"3.1.1"},{"location":"changelog/#310","text":"NEW : Start and end word boundary back references are now specified with \\m and \\M like Regex does. \\< and \\> have been removed from Regex. FIX : Escaped \\< and \\> are no longer processed as Re is known to escape these in versions less than Python 3.7.","title":"3.1.0"},{"location":"changelog/#305","text":"FIX : Process non raw string equivalent escaped Unicode on Python 2.7. FIX : Compiled objects should return the pattern string, not the pattern object via the property pattern .","title":"3.0.5"},{"location":"changelog/#304","text":"FIX : Formally enable Python 3.7 support. FIX : Tweak to Unicode wide character handling.","title":"3.0.4"},{"location":"changelog/#303","text":"FIX : Compiled search and replace objects should be hashable. FIX : Handle cases where a new compiled pattern object is passed back through compile functions.","title":"3.0.3"},{"location":"changelog/#302","text":"FIX : Bregex purge was calling Re's purge instead of Regex's purge.","title":"3.0.2"},{"location":"changelog/#301","text":"FIX : Do not accidentally \\. as a group in replace strings (don't use isdigit string method). FIX : Group names can start with _ in replace strings. FIX : Do not rely on Re for parsing string. FIX : Match behavior in \\g<group> parsing better. FIX : Raise some exceptions in a few places we weren't.","title":"3.0.1"},{"location":"changelog/#300","text":"NEW : Added new compile function that returns a pattern object that feels like Re's and Regex's pattern object. NEW : Add some caching of search and replace patterns. NEW : Completely refactored algorithm for search and replace pattern augmentation. NEW : Add support for \\e for escape character \\x1b in both Re and Regex. NEW : Add support for \\R for generic newlines in the Regex module (Regex only). NEW : Support Unicode property form \\pP and \\PP . NEW : Add support for properly handling per group, scoped verbose flags in the preprocess step (Regex). NEW : Handle (?#comments) properly in the preprocess step. NEW : Add support for \\N in byte strings (characters out of range won't be included). NEW : Add support for \\p and \\P in byte strings (characters out of range won't be included). NEW : Add support for \\< and \\> word boundary escapes. FIX : Missing block properties on narrow systems when the property starts beyond the narrow limit. FIX : Fix issue where an invalid general category could sometimes pass and return no characters. FIX : Fix \\Q...\\E behavior so it is applied first as a separate step. No longer avoids \\Q...\\E in things like character groups or comments. FIX : Flag related parsing issues in Regex and Re Python 3.6+.","title":"3.0.0"},{"location":"changelog/#220","text":"NEW : Proper support for \\N{Unicode Name} . FIX : Incomplete escapes will not be passed through, but will instead throw an error. For instance \\p should only be passed through if it is complete \\p{category} . Python 3.7 will error on this if we pass it through, and Python 3.6 will generate warnings. We should just consistently fail on it for all Python versions.","title":"2.2.0"},{"location":"changelog/#210","text":"NEW : Handle Unicode and byte notation in Re replace templates. NEW : Rework algorithm to handle replace casing back references in Python 3.7 development builds in preparation for Python 3.7 release. NEW : Add support for case back references when using the Regex module's subf and subfn . NEW : Add new convenience method expandf to Regex that can take a format string and apply format style replaces. NEW : Add FORMAT flag to compile_replace to apply format style replaces when applicable. NEW : Add the same support that Regex has in relation to format style replacements to Re. NEW : Compiled replacements are now immutable. NEW : Various logic checking proper types and values. FIX : Fix octal/group logic in Regex and Re. FIX : Fix issue dealing with trailing backslashes in replace templates.","title":"2.1.0"},{"location":"changelog/#200","text":"NEW : First attempt at bringing Python 3.7 support, fixing back reference logic, and adding new back reference. Released and then removed due to very poor behavior.","title":"2.0.0"},{"location":"changelog/#102","text":"FIX : Issues related to downloading Unicode data and Unicode table generation. Include Unicode data in release.","title":"1.0.2"},{"location":"changelog/#101","text":"FIX : Fixes for Python 3.6.","title":"1.0.1"},{"location":"changelog/#100","text":"NEW : Initial release.","title":"1.0.0"},{"location":"contributing/","text":"Contributing & Support \ue157 Overview \ue157 Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests. Bug Reports \ue157 Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code \ue157 Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Pull Requests \ue157 Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Feel free to use a virtual environment if you are concerned about installing any of the Python packages. Running Validation Tests \ue157 Make sure that Tox is installed: pip install tox Run Tox: tox Tox should install necessary dependencies and run the tests. Documentation Improvements \ue157 A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Contributing &amp; Support"},{"location":"contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"contributing/#overview","text":"Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests.","title":"Overview"},{"location":"contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"contributing/#pull-requests","text":"Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Feel free to use a virtual environment if you are concerned about installing any of the Python packages.","title":"Pull Requests"},{"location":"contributing/#running-validation-tests","text":"Make sure that Tox is installed: pip install tox Run Tox: tox Tox should install necessary dependencies and run the tests.","title":"Running Validation Tests"},{"location":"contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Documentation Improvements"},{"location":"installation/","text":"Installation \ue157 Overview \ue157 Backrefs doesn't have any required external dependencies. If desired, you can install the optional Regex module and use Backrefs with either Python's Re module or the Regex module. Installation \ue157 There are a couple of recommended ways to install Backrefs. If you would like to install in a virtual machine, you can do that as well. pip install backrefs Install locally from source via python setup.py build and python setup.py install . If developing Backrefs, you can install via pip install --editable . . This method will allow you to instantly see your changes without reinstalling which is great for developing.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#overview","text":"Backrefs doesn't have any required external dependencies. If desired, you can install the optional Regex module and use Backrefs with either Python's Re module or the Regex module.","title":"Overview"},{"location":"installation/#installation_1","text":"There are a couple of recommended ways to install Backrefs. If you would like to install in a virtual machine, you can do that as well. pip install backrefs Install locally from source via python setup.py build and python setup.py install . If developing Backrefs, you can install via pip install --editable . . This method will allow you to instantly see your changes without reinstalling which is great for developing.","title":"Installation"},{"location":"license/","text":"License \ue157 MIT license. Copyright \u00a9 2015 - 2019 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT license. Copyright \u00a9 2015 - 2019 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}